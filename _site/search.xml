<?xml version="1.0" encoding="utf-8"?>
<search>
  
    <entry>
      <title><![CDATA[JS解析与执行过程]]></title>
      <url>/js%E5%9F%BA%E7%A1%80/2018/09/25/js-carryout/</url>
      <content type="text"><![CDATA[]]></content>
      <categories>
        
          <category> JS基础 </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[leetcode5 最长回文子串]]></title>
      <url>/%E7%AE%97%E6%B3%95/2018/09/21/leetcode5/</url>
      <content type="text"><![CDATA[题目给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为1000。示例 1：输入: “babad” 输出: “bab”注意: “aba”也是一个有效答案。示例 2：输入: “cbbd” 输出: “bb”思路动态规划初始化一字母和二字母的回文，然后找到所有三字母回文，并依此类推。var longestPalindrome = function(s) {    var start=0;    var maxLength=1;    var len=s.length;    if(s.length&lt;2){        return s;    }    var dp=new Array(len);    for(var k=0;k&lt;dp.length;k++){        dp[k]=new Array(len);    }    for(var i=0;i&lt;len;i++){        dp[i][i]=true;        if(i&lt;len-1&amp;&amp;s.charAt(i)==s.charAt(i+1)){            dp[i][i+1]=true;            start=i;            maxLength=2;        }    }    for(var strlen=3;strlen&lt;len;strlen++){        for(var i=0;i&lt;=len-strlen;i++){            var j=i+strlen-1;            if(dp[i+1][j-1]&amp;&amp;s.charAt(i)==s.charAt(j)){                dp[i][j]=true;                start=i;                maxLength=strlen;            }        }    }    return s.substring(start,start+maxLength);}中心扩展算法回文中心的两侧互为镜像，所以回文可以从他的中心展开，有$2n-1$个这样的中心（包括字母和字母之间）取中心点向两边扩散的字符串求出其满足回文的长度。var longestPalindrome = function(s) {    if (s === '') {        return '';    }    let start = 0, end = 0;    for (let i = 0; i &lt; s.length; i++) {        let len1 = calc(s, i, i);        let len2 = calc(s, i, i + 1);        let len = Math.max(len1, len2);                if (len &gt; end - start) {            start = i - Math.floor((len - 1) / 2);            end = i + Math.floor(len / 2);        }    }    return s.substring(start, end + 1);};function calc(s, i, j) {    while (i &gt; -1 &amp;&amp; j &lt; s.length &amp;&amp; s[i] === s[j]) {        --i;        ++j;    }    return j - i - 1;}]]></content>
      <categories>
        
          <category> 算法 </category>
        
      </categories>
      <tags>
        
          <tag> leetcode </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[网易2018校招编程合集]]></title>
      <url>/%E7%AE%97%E6%B3%95/2018/09/18/test-ntes/</url>
      <content type="text"><![CDATA[题目来源于牛客网，网易2018校园招聘编程题真题集合。魔法币题目小易准备去魔法王国采购魔法神器,购买魔法神器需要使用魔法币,但是小易现在一枚魔法币都没有,但是小易有两台魔法机器可以通过投入x(x可以为0)个魔法币产生更多的魔法币。魔法机器1:如果投入x个魔法币,魔法机器会将其变为2x+1个魔法币魔法机器2:如果投入x个魔法币,魔法机器会将其变为2x+2个魔法币小易采购魔法神器总共需要n个魔法币,所以小易只能通过两台魔法机器产生恰好n个魔法币,小易需要你帮他设计一个投入方案使他最后恰好拥有n个魔法币。 输入描述:  输入包括一行,包括一个正整数n(1 ≤ n ≤ 10^9),表示小易需要的魔法币数量。输出描述:  输出一个字符串,每个字符表示该次小易选取投入的魔法机器。其中只包含字符’1’和’2’。思路这个很简单啦，机器1产生奇数，机器2产生偶数，从n按奇偶不断回推到0即可。function deal(n) {    var res=[];    while(n){        if(n%2==0){            res.push(2);            n=(n-2)/2;        }else{            res.push(1);            n=(n-1)/2;        }    }    return (res.reverse().join(""));}相反数题目为了得到一个数的”相反数”,我们将这个数的数字顺序颠倒,然后再加上原先的数得到”相反数”。例如,为了得到1325的”相反数”,首先我们将该数的数字顺序颠倒,我们得到5231,之后再加上原先的数,我们得到5231+1325=6556.如果颠倒之后的数字有前缀零,前缀零将会被忽略。例如n = 100, 颠倒之后是1. 输入描述:  输入包括一个整数n,(1 ≤ n ≤ 10^5)输出描述:  输出一个整数,表示n的相反数思路太简单了…水题 :see_no_evil:function deal(str) {    var num1=parseInt(str);    var restr=str.split("").reverse().join("");    var num2=parseInt(restr);    return (num1+num2);}字符串碎片题目一个由小写字母组成的字符串可以看成一些同一字母的最大碎片组成的。例如,”aaabbaaac”是由下面碎片组成的:’aaa’,’bb’,’c’。牛牛现在给定一个字符串,请你帮助计算这个字符串的所有碎片的平均长度是多少。输入描述:  输入包括一个字符串s,字符串s的长度length(1 ≤ length ≤ 50),s只含小写字母(‘a’-‘z’)输出描述:  输出一个整数,表示所有碎片的平均长度,四舍五入保留两位小数。  如样例所示: s = “aaabbaaac”所有碎片的平均长度 = (3 + 2 + 3 + 1) / 4 = 2.25思路碎片的平均长度=字符串长度/相同字母团构成的字符串的个数，通过遍历字符串比较前后两个位置字符是否相等，记录去重长度。function deal(str) {    var num=1;    var temp=str[0];    for(var i=1;i&lt;str.length;i++){        if(str[i]!=temp){            num++;        }        temp=str[i];    }    return ((str.length/num).toFixed(2));}游历魔法王国题目魔法王国一共有n个城市,编号为0~n-1号,n个城市之间的道路连接起来恰好构成一棵树。小易现在在0号城市,每次行动小易会从当前所在的城市走到与其相邻的一个城市,小易最多能行动L次。如果小易到达过某个城市就视为小易游历过这个城市了,小易现在要制定好的旅游计划使他能游历最多的城市,请你帮他计算一下他最多能游历过多少个城市(注意0号城市已经游历了,游历过的城市不重复计算)。输入描述:  输入包括两行,第一行包括两个正整数n(2 ≤ n ≤ 50)和L(1 ≤ L ≤ 100),表示城市个数和小易能行动的次数。第二行包括n-1个整数parenti, 对于每个合法的i(0 ≤ i ≤ n - 2),在(i+1)号城市和parent[i]间有一条道路连接。输出描述:  输出一个整数,表示小易最多能游历的城市数量。思路首先考虑二叉树的深度遍历，但数组序列化为二叉树没写出来。题目重点在第二行，即0——i-1的节点各自对应的父节点，且父节点值&lt;字节点。用动态规划求解。递归方程$dp[i]=dp[i-1]+1$分两种情况，最长树链maxLen，步数L(1) L&lt;=MaxLen,城市数量(L+1)  (2) L&gt;MaxLen,城市数量Math.min(n, maxLen + (L - maxLen) / 2 + 1)function deal(n,l,arr){    var maxLen=0;    var dp=[];    dp[0]=0;    for(var i=0;i&lt;n-1;i++){        dp[i+1]=dp[arr[i]]+1;        maxLen=Math.max(dp[i+1],maxLen);    }    if(l&lt;=maxLen){        return (l+1);    }else{        return Math.min(n,maxLen + Math.floor((l- maxLen) / 2) + 1)    }}重排数列题目小易有一个长度为N的正整数数列A = {A[1], A[2], A[3]…, A[N]}。牛博士给小易出了一个难题:对数列A进行重新排列,使数列A满足所有的A[i] * Ai + 1都是4的倍数。小易现在需要判断一个数列是否可以重排之后满足牛博士的要求。 输入描述:  输入的第一行为数列的个数t(1 ≤ t ≤ 10),接下来每两行描述一个数列A,第一行为数列长度n(1 ≤ n ≤ 10^5)第二行为n个正整数Ai输出描述:  对于每个数列输出一行表示是否可以满足牛博士要求,如果可以输出Yes,否则输出No。思路找规律题～～但考虑不要太过详细。数列满足要求有以下三种情况(1) 全部能被2整除(2) 能被4整除的数&gt;=数列个数的一半，剩下的数插空法补足数列(3) 奇数的个数-1&lt;=能被4整除的个数，一个能被4整除的数最多带一个奇数，即（能被2整除+能被4整除）&gt;=数列长度。function deal(arr){    var count4=0,count2=0;    for(var i=0;i&lt;arr.length;i++){        if(arr[i]%4==0){            count4++;        }        if(arr[i]%2==0){            count2++;        }    }    if(count2==arr.length||count4&gt;=parseInt(arr.length/2)||count2+count4&gt;=arr.length){        return 'Yes';    }else{        return 'No';    }}最长公共子括号序列题目小易给出一个合法的括号匹配序列s,小易希望你能找出具有以下特征的括号序列t:1、t跟s不同,但是长度相同2、t也是一个合法的括号匹配序列3、LCS(s, t)是满足上述两个条件的t中最大的因为这样的t可能存在多个,小易需要你计算出满足条件的t有多少个。如样例所示: s = “(())()”,跟字符串s长度相同的合法括号匹配序列有:“()(())”, “((()))”, “()()()”, “(()())”,其中LCS( “(())()”, “()(())” )为4,其他三个都为5,所以输出3.输入描述:  输入包括字符串s(4 ≤ s.length ≤ 50),保证s是一个合法的括号匹配序列。输出描述:  输出一个正整数,满足条件的t的个数。思路这道题的题干太长了，但其实没那么复杂。根据题意，要想使得 LCS 最大，删去任意一个字符即可获得 $LCS = |s| - 1$ ，再把该字符插到与原来不同的任意位置可以维持原长度，而不影响 LCS 的计算。function deal(str){	var res=new Set();	for(var i=str.length-2;i&gt;0;i--){	    var arr=str.split("")	    var temp=arr[i];	    arr.splice(i,1);	    for(var j=arr.length-1;j&gt;=0;j--){	        arr.splice(j,0,temp);	        if(vaild(arr)){	            res.add(arr.join(""))	        }	        arr.splice(j,1)	    }	}	if(res.has(str)){		res.delete(str);	}	return res.size;}function vaild(a){    var stack=[];    for(var k=0;k&lt;a.length;k++){        if(a[k]=="("){            stack.push("(");        }else{            stack.pop();        }    }    return stack.length==0;}参考Leetcode22 括号生成  给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合/** * @param {number} n * @return {string[]} */var generateParenthesis = function(n) {    var ans=new Set();       generate(n,0,0,"",ans);    return Array.from(ans);};function generate(n,left,right,ret,ans){    if(left+right==2*n){        ans.add(ret);        return ;    }    if(left&lt;n){        generate(n,left+1,right,ret+"(",ans)        if(right&lt;left){            generate(n,left,right+1,ret+")",ans);        }    }else{        generate(n,left,right+1,ret+")",ans);    }}合唱题目小Q和牛博士合唱一首歌曲,这首歌曲由n个音调组成,每个音调由一个正整数表示。对于每个音调要么由小Q演唱要么由牛博士演唱,对于一系列音调演唱的难度等于所有相邻音调变化幅度之和, 例如一个音调序列是8, 8, 13, 12, 那么它的难度等于|8 - 8| + |13 - 8| + |12 - 13| = 6(其中||表示绝对值)。现在要对把这n个音调分配给小Q或牛博士,让他们演唱的难度之和最小,请你算算最小的难度和是多少。如样例所示: 小Q选择演唱{5, 6}难度为1, 牛博士选择演唱{1, 2, 1}难度为2,难度之和为3,这一个是最小难度和的方案了。 输入描述:  输入包括两行,第一行一个正整数n(1 ≤ n ≤ 2000) 第二行n个整数vi, 表示每个音调。输出描述:  输出一个整数,表示小Q和牛博士演唱最小的难度和是多少。思路贪心算法第一个人唱低音，第二个人唱高音，先把数组排个序，然后选择前一部分作为低音，后一部分作为高音。分割的标准是两个元素间隔最大的地方。不过这样做只能通过60%的样例。动态规划(1)$dp[i][j]$（永远有i &gt; j）表示某一个人最近唱的音为第i个，另一个人最近唱的是第j个时最小的难度(2)由于只由一个人唱完肯定不是最优解。因此先在一个for循环内确定以下两种情况的初值$dp[i][0]$第二个人唱第一个音，第一个人唱后面所有音$dp[i][i-1]$第一个人唱最近的一个音，第二个人唱前面所有音(3)$dp[i][j]$转移方程,每当交换唱歌次序，两人最近一次唱的音符一定是相邻的，所以底下分相邻和不相邻讨论：  当$j == i - 1$，即交换唱歌次序，$dp[i][i-1]$时，表明第一个人上一个音可能在第k个音$(0&lt;=k&lt;i-1)$,由唱了最近的第$i$个，第二个人仍然留在第$i-1$个音。$dp[i][i-1]=$ 对所有k求$min(dp[i-1][k] + abs(arr[i] - arr[k]))$ 其中（$0&lt;= k&lt;i-1$）  当$j&lt;i-1$，即不交换唱歌次序时，只可能由唱到$i-1$音符的人续唱$dp[i][j] = dp[i-1][j] + abs(arr[i] - arr[i-1])$(4)最后求出所有$dp[len-1][]$里的最小值即为全局最优解射击游戏题目小易正在玩一款新出的射击游戏,这个射击游戏在一个二维平面进行,小易在坐标原点(0,0),平面上有n只怪物,每个怪物有所在的坐标(x[i], y[i])。小易进行一次射击会把x轴和y轴上(包含坐标原点)的怪物一次性消灭。小易是这个游戏的VIP玩家,他拥有两项特权操作:1、让平面内的所有怪物同时向任意同一方向移动任意同一距离2、让平面内的所有怪物同时对于小易(0,0)旋转任意同一角度小易要进行一次射击。小易在进行射击前,可以使用这两项特权操作任意次。小易想知道在他射击的时候最多可以同时消灭多少只怪物,请你帮帮小易。如样例所示:所有点对于坐标原点(0,0)顺时针或者逆时针旋转45°,可以让所有点都在坐标轴上,所以5个怪物都可以消灭。输入描述:  输入包括三行。第一行中有一个正整数n(1 ≤ n ≤ 50),表示平面内的怪物数量。第二行包括n个整数xi,表示每只怪物所在坐标的横坐标,以空格分割。第二行包括n个整数yi,表示每只怪物所在坐标的纵坐标,以空格分割。输出描述:  输出一个整数表示小易最多能消灭多少只怪物。挖个坑后两道感觉挺难的，呜呜呜先参考大神思路，代码再再补上。:sob: :sob: :sob:]]></content>
      <categories>
        
          <category> 算法 </category>
        
      </categories>
      <tags>
        
          <tag> 网易 </tag>
        
          <tag> 动态规划 </tag>
        
          <tag> leetcode </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[从输入URL到页面加载的过程]]></title>
      <url>/http/2018/09/17/http-url/</url>
      <content type="text"><![CDATA[前言经典面试题，但方方面面的很多东西，要答好也不简单。通过对这道题的分析，希望梳理出一个前端向的知识体系 :dancers: :dancers: :dancers:主要包括：  从浏览器接收url到开启网络请求线程  开启网络线程到发出一个完整的http请求  从服务器接收到请求到对应后台接收到请求  后台和前台的http交互  缓存问题，http缓存总结  解析页面流程  CSS的可视化格式模型  JS引擎解析过程从浏览器接收url到开启网络请求线程线程与进程进程和线程的对比网上大多是概念性的解释，要真正理解进程与线程中的时间片和其他精彩的“调度概念”之前，建立一个类比，首先来说明线程和进程是如何工作的。作为房子使用常规的日常对象 - 房子来对进程和线程进行类比。房子实际上是一个容器，具有某些属性（例如占地面积，卧室数量等）。房子本身并没有主动做 任何事情 - 这是一个被动的对象。这实际上是一个进程。  住在房子里的人是活跃的对象 - 他们是使用各种房间，看电视，做饭，洗澡等等。线程的行为方式。单线程如果你住在自己的房子里，那么你可以在任何时间做任何事，因为房子里没有其他人。你可以打开电视，使用洗手间，吃晚餐等等，只需要继续操作即可。多线程当把另一个人加入房子时，你不能在任何一个点上进入洗手间，你需要先检查一下，洗手间有没有人。如果有两个负责任的成年人住在一个​​房子里，一般来说可以合理地对“安全”松懈，你知道另一个成年人会尊重你的空间，不会让厨房着火等等。现在，把几个孩子扔进去，事情变得更加复杂。回到线程与进程在macOS系统中，可以打开活动监视器查看后台进程与线程，和内存资源信息和CPU占有率。进程进程是一个具有一定独立功能的程序在一个数据集上的一次动态执行的过程，是操作系统进行资源分配和调度的一个独立单位，是应用程序运行的载体。线程由于进程对于CPU的使用是轮流的，那么就存在进程的切换，但是由于现在的程序都比较大，切换的开销很大会浪费CPU的资源，于是就发明了线程，把一个大的进程分解成多个线程共同执行。区别  进程是操作系统分配资源的最小单位，线程是程序执行的最小单位。  一个进程由一个或多个线程组成，线程是一个进程中代码的不同执行路线；  进程之间相互独立，但同一进程下的各个线程之间共享程序的内存空间(包括代码段、数据集、堆等)及一些进程级的资源(如打开文件和信号)。  调度和切换：线程上下文切换比进程上下文切换要快得多。浏览器是多进程的浏览器是多进程的，有一个主控进程，以及每一个tab页面都会新开一个进程（某些情况下多个tab会合并进程）。如图，查看chrome任务管理器。浏览器进程包括  Browser进程：浏览器的主进程（负责协调、主控），只有一个  第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建  GPU进程：最多一个，用于3D绘制  浏览器渲染进程（内核）：默认每个Tab页面一个进程，互不影响，控制页面渲染，脚本执行，事件处理等（有时候会优化，如多个空白tab会合并成一个进程）浏览器内核是多线程浏览器内核简单来说浏览器内核是通过取得页面内容、整理信息（应用CSS）、计算和组合最终输出可视化的图像结果，通常也被称为渲染引擎。从上面我们可以知道，Chrome浏览器为每个tab页面单独启用进程，因此每个tab网页都有由其独立的渲染引擎实例。浏览器内核是多线程，在内核控制下各线程相互配合以保持同步，一个浏览器通常由以下常驻线程组成：  GUI 渲染线程（图形用户界面）  JavaScript引擎线程  事件触发线程  定时触发器线程  异步http请求线程GUI 渲染线程GUI渲染线程负责渲染浏览器界面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等。当界面需要重绘(Repaint)或由于某种操作引发回流(reflow)时,该线程就会执行。GUI渲染线程与JS引擎线程是互斥的 在Javascript引擎运行脚本期间,GUI渲染线程都是处于挂起状态的,也就是说被”冻结”了.JavaScript引擎线程Javascript引擎可以称为JS内核，主要负责处理Javascript脚本程序，例如V8引擎。Javascript引擎线程理所当然是负责解析Javascript脚本，运行代码。一个Tab页（renderer进程）中无论什么时候都只有一个JS线程在运行JS程序。Javascript是单线程的Javascript是单线程的, 那么为什么Javascript要是单线程的？这是因为Javascript这门脚本语言诞生的使命所致：JavaScript为处理页面中用户的交互，以及操作DOM树、CSS样式树来给用户呈现一份动态而丰富的交互体验和服务器逻辑的交互处理。如果JavaScript是多线程的方式来操作这些UI DOM，则可能出现UI操作的冲突； 如果Javascript是多线程的话，在多线程的交互下，处于UI中的DOM节点就可能成为一个临界资源，假设存在两个线程同时操作一个DOM，一个负责修改一个负责删除，那么这个时候就需要浏览器来裁决如何生效哪个线程的执行结果。当然我们可以通过锁来解决上面的问题。但为了避免因为引入了锁而带来更大的复杂性，Javascript在最初就选择了单线程执行。事件触发线程当一个事件被触发时该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理。这些事件可以是当前执行的代码块如定时任务、也可来自浏览器内核的其他线程如鼠标点击、AJAX异步请求等，但由于JS的单线程关系所有这些事件都得排队等待JS引擎处理。定时触发器线程浏览器定时计数器并不是由JavaScript引擎计数的, 因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确, 因此通过单独线程来计时并触发定时是更为合理的方案。setInterval与setTimeout所在线程，W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms。异步http请求线程在XMLHttpRequest在连接后是通过浏览器新开一个线程请求， 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件放到 JavaScript引擎的处理队列中等待处理。GUI 渲染线程 与 JavaScript引擎线程互斥由于JavaScript是可操纵DOM的，如果在修改这些元素属性同时渲染界面（即JavaScript线程和UI线程同时运行），那么渲染线程前后获得的元素数据就可能不一致了。因此为了防止渲染出现不可预期的结果，浏览器设置GUI渲染线程与JavaScript引擎为互斥的关系，当JavaScript引擎执行时GUI线程会被挂起，GUI更新会被保存在一个队列中等到引擎线程空闲时立即被执行。开启网络线程到发出一个完整的http请求DNS查询得到IP  如果输入的是域名，需要进行DNS解析成IP，查询步骤：  浏览器缓存  本机缓存  hosts文件  路由器缓存  ISP DNS缓存  DNS递归查询（可能存在负载均衡导致每次IP不一样）    TCP/IP请求    TCP三次握手      总结三次握手过程：  第一次握手：起初两端都处于CLOSED关闭状态，Client将标志位SYN置为1，随机产生一个值seq=x，并将该数据包发送给Server，Client进入SYN-SENT状态，等待Server确认；  第二次握手：Server收到数据包后由标志位SYN=1得知Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=x+1，随机产生一个值seq=y，并将该数据包发送给Client以确认连接请求，Server进入SYN-RCVD状态，此时操作系统为该TCP连接分配TCP缓存和变量；  第三次握手：Client收到确认后，检查ack是否为x+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=y+1，并且此时操作系统为该TCP连接分配TCP缓存和变量，并将该数据包发送给Server，Server检查ack是否为y+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client和Server就可以开始传输数据。TCP四次挥手总结四次挥手过程：起初A和B处于ESTABLISHED状态——A发出连接释放报文段并处于FIN-WAIT-1状态——B发出确认报文段且进入CLOSE-WAIT状态——A收到确认后，进入FIN-WAIT-2状态，等待B的连接释放报文段——B没有要向A发出的数据，B发出连接释放报文段且进入LAST-ACK状态——A发出确认报文段且进入TIME-WAIT状态——B收到确认报文段后进入CLOSED状态——A经过等待计时器时间2MSL后，进入CLOSED状态。GET,POST区别GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。GET产生一个TCP数据包,POST产生两个TCP数据包。对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据） 而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）TCP/IP协议栈从服务器接收到请求到对应后台接收到请求负载均衡用户发起的请求都指向调度服务器（反向代理服务器，譬如安装了nginx控制负载均衡），然后调度服务器根据实际的调度算法，分配不同的请求给对应集群中的服务器执行，然后调度器等待实际服务器的HTTP响应，并将它反馈给用户。后台的处理  后端是有统一的验证的，如安全拦截，跨域验证等。如不符合规则，直接返回相应的http报文（如拒绝请求等）  当验证通过后，进入实际的后台代码，此时是程序接收到请求，然后执行（譬如查询数据库，大量计算等等）  等程序执行完毕后，就会返回一个http响应包（会经过多层封装）,将这个包从后端发送到前端，完成交互后台和前台的http交互HTTP报文结构包括：报文首部 空行（CR+LF）报文主体 。通常，不一定要有报文主体。请求报文的报文首部包括：请求行 请求首部字段 通用首部字段 实体首部字段 其他请求行包含请求方法、请求URI和HTTP版本（还应该以回车换行符CRLF结尾），如：GET /index.html HTTP/1.1请求方法：  GET：最常见，向服务器请求某个资源  POST：起初用于向服务器输入数据。实际上，通常用于HTML表单数据的提交  HEAD：与GET的行为类似，但服务器返回的响应中只包含首部，不会返回主体部分  PUT：向服务器写入文档  DELETE：删除指定资源  TRACE：服务器回送收到的请求信息给客户端，主要用于诊断  CONNECT  OPTIONS：查询服务器支持的方法（通用或针对指定资源）响应报文的报文首部包括：状态行 响应首部字段 通用首部字段 实体首部字段 其他状态行包含表明响应结果的状态码、原因短语和HTTP版本，如：HTTP/1.1 200 OK状态码（常见）：  1×× Informational 信息性状态码100 Continue101 Switching Protocols  2×× Success 成功状态码200 OK 成功204 No Content 成功，但不返回任何实体的主体部分206 Partial Content 成功执行了一个范围（Range）请求  3×× Redirection 重定向状态码301 Moved Permanently 永久性重定向，响应报文的Location首部应该有该资源的新URL302 Found 临时性重定向，响应报文的Location首部给出的URL用来临时定位资源303 See Other 请求的资源存在着另一个URI，客户端应使用GET方法定向获取请求的资源304 Not Modified 客户端发送附带条件的请求（请求首部中包含如If-Modified-Since等指定首部）时，服务端有可能返回304，此时，响应报文中不包含任何报文主体。307 Temporary Redirect 临时重定向。与302 Found含义一样。302禁止POST变换为GET，但实际使用时并不一定，307则更多浏览器可能会遵循这一标准，但也依赖于浏览器具体实现。  4×× Client Error 客户端错误状态码400 Bad Request 请求报文中存在语法错误401 Unauthorized需要认证，会有适当的首部一同返回404 Not Found 服务器上无法找到请求的资源  5×× Server Error 服务器错误状态码500 Internel Server Error 服务端在执行请求时发生了错误503 Service Unavailable 服务器暂时无法提供服务，可以包含Retry-After首部首部字段HTTP首部字段按照实际用途被分为通用首部字段（General Header Fields）、请求首部字段（Request Header Fields）、响应首部字段（Response Header Fields）和实体首部字段（Entity Header Fields）。     按照首部字段在有代理时的不同行为，首部字段又可以分为端到端首部（End-to-end Header）和逐跳首部（Hop-by-hop Header）。逐跳首部只对单次转发有效，经过缓存或代理后不再转发，HTTP/1.1和之后的版本中，要使用逐跳首部时需提供Connection首部字段。端到端首部则会一直发送给最终接收目标。通用头部Request Url: 请求的web服务器地址Request Method: 请求方式（Get、POST、OPTIONS、PUT、HEAD、DELETE、CONNECT、TRACE）Status Code: 请求的返回状态码，如200代表成功Remote Address: 请求的远程服务器地址（会转为IP）常用的请求头部Accept: 接收类型，表示浏览器支持的MIME类型（对标服务端返回的Content-Type）Accept-Encoding：浏览器支持的压缩类型,如gzip等,超出类型不能接收Content-Type：客户端发送出去实体内容的类型Cache-Control: 指定请求和响应遵循的缓存机制，如no-cacheIf-Modified-Since：对应服务端的Last-Modified，用来匹配看文件是否变动，只能精确到1s之内，http1.0中Expires：缓存控制，在这个时间内不会请求，直接使用缓存，http1.0，而且是服务端时间Max-age：代表资源在本地缓存多少秒，有效时间内不会请求，而是使用缓存，http1.1中If-None-Match：对应服务端的ETag，用来匹配文件内容是否改变（非常精确），http1.1中Cookie: 有cookie并且同域访问时会自动带上Connection: 当浏览器与服务器通信时对于长连接如何进行处理,如keep-aliveHost：请求的服务器URLOrigin：最初的请求是从哪里发起的（只会精确到端口）,Origin比Referer更尊重隐私Referer：该页面的来源URL(适用于所有类型的请求，会精确到详细页面地址，csrf拦截常用到这个字段)User-Agent：用户客户端的一些必要信息，如UA头部等常用的响应头部Access-Control-Allow-Headers: 服务器端允许的请求HeadersAccess-Control-Allow-Methods: 服务器端允许的请求方法Access-Control-Allow-Origin: 服务器端允许的请求Origin头部（譬如为*）Content-Type：服务端返回的实体内容的类型Date：数据从服务器发送的时间Cache-Control：告诉浏览器或其他客户，什么环境可以安全的缓存文档Last-Modified：请求资源的最后修改时间Expires：应该在什么时候认为文档已经过期,从而不再缓存它Max-age：客户端的本地资源应该缓存多少秒，开启了Cache-Control后有效ETag：请求变量的实体标签的当前值Set-Cookie：设置和页面关联的cookie，服务器通过这个头部把cookie传给客户端Keep-Alive：如果客户端有keep-alive，服务端也会有响应（如timeout=38）Server：服务器的一些相关信息cookie及其优化cookie是浏览器的一种本地存储方式，一般用来帮助客户端和服务端通信的，常用来进行身份校验，结合服务端的session使用。Cookie的作用  解决了认证（登录）后，下次访问还需要认证（登录）的重复认证问题。  可以记住用户名和密码，增强用户体验。Cookie的缺点  安全问题cookie数据保存在客户端，有可能被篡改或盗取。Cookie 数据可以被访问到，就像我们前面通过 Firefox 的插件 HttpFox 可以看到所有的 Cookie 值。不仅可以查看 Cookie，甚至可以通过 Firecookie 插件添加、修改 Cookie，所以 Cookie 的安全性受到了很大的挑战。相比较而言 Session 的安全性要高很多，因为 Session 是将数据保存在服务端，只是通过 Cookie 传递一个 SessionID 而已，所以 Session 更适合存储用户隐私和重要的数据。  数据传输量大的问题cookie 可以让服务端程序跟踪每个客户端的访问，但是每次客户端的访问都必须传回这些 cookie，如果 cookie 很多，这无形地增加了客户端与服务端的数据传输量，而 Session 的出现正是为了解决这个问题。浏览器会附带具有相同域名的所有cookie，如果是二级域名，顶级域名的cookie也会一起附带。同一个客户端每次和服务端交互时，不需要每次都传回所有的 Cookie 值，而是只要传回一个 ID，这个 ID 是客户端第一次访问服务器的时候生成的，而且每个客户端是唯一的。这样每个客户端就有了一个唯一的 ID，客户端只要传回这个 ID 就行了，这个 ID 通常是 NANE 为 JSESIONID 的一个 Cookie。  浏览器对cookie的数量和大小有限制http1.0 http1.1 http2.0 httpsHTTP1.0 HTTP 1.1主要区别长连接HTTP 1.0需要使用keep-alive参数来告知服务器端要建立一个长连接，而HTTP1.1默认支持长连接。Connection: keep-aliveHTTP是基于TCP/IP协议的，创建一个TCP连接是需要经过三次握手的,有一定的开销，如果每次通讯都要重新建立连接的话，对性能有影响。因此最好能维持一个长连接，可以用个长连接来发多个请求。节约带宽HTTP 1.1支持只发送header信息(不带任何body信息)，如果服务器认为客户端有权限请求服务器，则返回100，否则返回401。客户端如果接受到100，才开始把请求body发送到服务器。这样当服务器返回401的时候，客户端就可以不用发送请求body了，节约了带宽。另外HTTP还支持传送内容的一部分。这样当客户端已经有一部分的资源后，只需要跟服务器请求另外的部分资源即可。这是支持文件断点续传的基础。HOST域现在可以web server例如tomat，设置虚拟站点是非常常见的，也即是说，web server上的多个虚拟站点可以共享同一个ip和端口。HTTP1.0是没有host域的，HTTP1.1才支持这个参数。HTTP1.1 HTTP 2.0主要区别多路复用HTTP2.0使用了多路复用的技术，做到同一个连接并发处理多个请求，而且并发请求的数量比HTTP1.1大了好几个数量级。当然HTTP1.1也可以多建立几个TCP连接，来支持处理更多并发的请求，但是创建TCP连接本身也是有开销的。TCP连接有一个预热和保护的过程，先检查数据是否传送成功，一旦成功过，则慢慢加大传输速度。因此对应瞬时并发的连接，服务器的响应就会变慢。所以最好能使用一个建立好的连接，并且这个连接可以支持瞬时并发的请求。关于多路复用，可以参看学习NIO 。数据压缩HTTP1.1不支持header数据的压缩，HTTP2.0使用HPACK算法对header的数据进行压缩，这样数据体积小了，在网络上传输就会更快。服务器推送意思是说，当我们对支持HTTP2.0的web server请求数据的时候，服务器会顺便把一些客户端需要的资源一起推送到客户端，免得客户端再次创建连接发送请求到服务器端获取。这种方式非常合适加载静态资源。服务器端推送的这些资源其实存在客户端的某处地方，客户端直接从本地加载这些资源就可以了，不用走网络，速度自然是快很多的。HTTP HTTPSHTTP全称是HyperText Transfer Protocal，即：超文本传输协议，HTTP连接最显著的特点是客户端发送的每次请求都需要服务器回送响应，在请求结束后，会主动释放连接。从建立连接到关闭连接的过程称为“一次连接”。HTTPS通信原理HTTPS（Secure Hypertext Transfer Protocol）安全超文本传输协议 它是一个安全通信通道HTTPS是HTTP over SSL/TLS，HTTP是应用层协议，TCP是传输层协议，在应用层和传输层之间，增加了一个安全套接层SSL/TLS：SSL (Secure Socket Layer，安全套接字层)TLS (Transport Layer Security，传输层安全协议)SSL使用40 位关键字作为RC4流加密算法Https的作用  内容加密 建立一个信息安全通道，来保证数据传输的安全；  身份认证 确认网站的真实性  数据完整性 防止内容被第三方冒充或者篡改Https和Http的区别  https协议需要到CA申请证书。  http是超文本传输协议，信息是明文传输；https 则是具有安全性的ssl加密传输协议。  http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。  http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。  http默认使用80端口，https默认使用443端口缓存问题另开一篇，http缓存总结解析页面流程渲染机制浏览器内核拿到内容后，渲染步骤大致可以分为以下几步：  解析HTML，构建DOM树  解析CSS，生成CSS规则树  合并DOM树和CSS规则，生成render树  布局render树（Layout/reflow），负责各元素尺寸、位置的计算  绘制render树（paint），绘制页面像素信息  浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显示在屏幕上在构建 CSSOM 树时，会阻塞渲染，直至 CSSOM 树构建完成。并且构建 CSSOM 树是一个十分消耗性能的过程，所以应该尽量保证层级扁平，减少过度层叠，越是具体的 CSS 选择器，执行速度越慢。当 HTML 解析到 script 标签时，会暂停构建 DOM，完成后才会从暂停的地方重新开始。也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件。并且 CSS 也会影响 JS 的执行，只有当解析完样式表才会执行 JS，所以也可以认为这种情况下，CSS 也会暂停构建 DOM。Load 和 DOMContentLoaded 区别Load 事件触发代表页面中的 DOM，CSS，JS，图片已经全部加载完毕。DOMContentLoaded 事件触发代表初始的 HTML 被完全加载和解析，不需要等待 CSS，JS，图片加载。图层一般来说，可以把普通文档流看成一个图层。特定的属性可以生成一个新的图层。不同的图层渲染互不影响，所以对于某些频繁需要渲染的建议单独生成一个新图层，提高性能。但也不能生成过多的图层，会引起反作用。通过以下几个常用属性可以生成新图层  3D 变换：translate3d、translateZ  will-change  video、iframe 标签  通过动画实现的 opacity 动画转换  position: fixed更多可参考简单图层与复合图层重绘（Repaint）和回流（Reflow）重绘和回流是渲染步骤中的一小节，但是这两个步骤对于性能影响很大。  重绘是当节点需要更改外观而不会影响布局的，比如改变 color 就叫称为重绘  回流是布局或者几何属性需要改变就称为回流。回流必定会发生重绘，重绘不一定会引发回流。回流所需的成本比重绘高的多，改变深层次的节点很可能导致父节点的一系列回流。什么会引起回流  页面渲染初始化  DOM结构改变，比如删除了某个节点  render树变化，比如减少了padding  窗口resize  最复杂的一种：获取某些属性，引发回流很多浏览器会对回流做优化，会等到数量足够时做一次批处理回流，但是除了render树的直接变化，当获取一些属性时，浏览器为了获得正确的值也会触发回流，这样使得浏览器优化无效，包括          offset(Top/Left/Width/Height)      scroll(Top/Left/Width/Height)      cilent(Top/Left/Width/Height)      width,height      调用了getComputedStyle()或者IE的currentStyle      减少重绘和回流  使用 translate 替代 top  使用 visibility 替换 display: none ，因为前者只会引起重绘，后者会引发回流（改变了布局）  把 DOM 离线后修改，比如：先把 DOM 给 display:none (有一次 Reflow)，然后你修改100次，然后再把它显示出来  不要把 DOM 结点的属性值放在一个循环里当成循环里的变量  不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局  动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使用 requestAnimationFrame  CSS 选择符从右往左匹配查找，避免 DOM 深度过深  将频繁运行的动画变为图层，图层能够阻止该节点回流影响别的元素。比如对于 video 标签，浏览器会自动将该节点变为图层。CSS的可视化格式模型CSS的可视化格式模型就是规定了浏览器在页面中如何处理文档树  CSS中规定每一个元素都有自己的盒子模型（相当一规定了这个元素如何显示），然后可视化格式模型则是把这些盒子模型按照规则摆放到页面上，也就是如何布局，换句话说，盒子模型规定了怎么在页面上摆放盒子，盒子的相互作用等等。定位机制CSS三种定位机制：普通流、浮动流、绝对定位包含块（Containing Block）一个元素的box的定位和尺寸，会与某一矩形框有关，这个框就称之为包含块。元素会为它的子孙元素创建包含块，但是，并不是说元素的包含块就是它的父元素，元素的包含块与它的祖先元素的样式等有关系譬如：  根元素是最顶端的元素，他没有父节点，它的包含块就是初始化包含块；  static和relative的包含块由他最近的块级、单元格或者行内块祖先元素的内容框（content）创建；  fixed的包含块就是当前可视窗口；  absolute的包含块由他最近的position属性值不为static的祖先元素创建：          如果其祖先元素是行内元素，则包含块取决于其祖先元素的direction特性；      如果祖先元素不是行内元素，那么包含块的区域应该是祖先元素的内边距边界。      控制框（Controlling Box）块级元素和块框以及行内元素和行框的相关概念块框  块级元素会生成一个块框（Block Box），块框会占据一整行，用来包含子box和生成的内容  块框同时也是一个块包含框（Containing Box），里面要么只包含块框，要么只包含行内框（不能混杂）  如果块框内部有块级元素也有行内元素，那么行内元素会被匿名块框包围如果一个块框在其中包含另外一个块框，那么我们强迫它只能包含块框，因此其它文本内容生成出来的都是匿名块框（而不是匿名行内框）行内框  一个行内元素生成一个行内框  行内元素能排在一行，允许左右有其它元素display属性的影响  block，元素生成一个块框；  inline，元素产生一个或多个的行内框；  inline-block，元素产生一个行内级块框，行内块框的内部会被当做块框来格式化，而此元素本身会被当作行内级框来格式化（这也是为什么会产生BFC）；  none，不生成框，不再格式化结构中，而另一个visibility：hidden则会产生一个不可见的框总结如果一个框里，有一个块级元素，那么这个框里的内容都会被当作块框来进行格式化，因为只要出现了块级元素，就会将里面的内容分成几块，每一块独占一行（出现行内可以用匿名块框解决）如果一个框里，没有任何块级元素，那么这个框里的内容会被当成行内框来格式化，因为里面的内容时按照顺序成行的排列。FC（Formatting Context）FC即格式化上下文，它定义框内部的元素渲染规则，比较抽象，譬如：  FC就像是一个大箱子，里面装有很多元素；  箱子可以隔开里面的元素和外面的元素（所以外部并不会影响FC内部的渲染）  内部的规则可以是：如何定位、宽高计算、margin折叠等等不同类型的框参与的FC类型不同，譬如块级框对应BFC，行内框对应IFC注意：并不是说所有的框都会产生FC，而是符合特定的条件才会产生，只有产生了对应的FC后才会应用对应的FC渲染规则BFC规则在块格式化上下文中，每一个元素左外边与包含块的左边解除（对于从右到左的格式化，右外边接触右边），即使存在浮动也是如此（所以浮动元素正常会直接贴近它的包含块的左边，与普通元素重合），除非这个元素也创建了一个新的BFC；BFC特点  内部box在垂直方向，一个接一个的放置；  box的垂直方向由margin决定，属于同一个BFC的两个box间的margin会重叠  BFC区域不会与float box重叠（可用于排版）  BFC就是页面上的一个隔离的独立容器，容器里的子元素不会影响到外面的元素，反之也是如此  计算BFC的高度时，浮动元素也参与计算（不会浮动塌陷如overflow：hidden清除浮动就是这个原理）如何触发BFC  根元素；  float属性不为none  position为absolute或fixed  display为inline-block、flex、inline-flex、table、table-cell、table-caption  overflow不为visible  display：table，本身不会产生BFC，但是他会产生匿名框（包含display：table-cell的框），而这个匿名框产生BFC。IFC规则在行内格式化上下文中，框一个接一个地水平排列，起点是包含块的顶部。水平方向上的margin，border和padding在框之间得到保留，框在垂直方向上可以以不同的方式对齐；它们的顶部或底部对齐，或根据其中文字的基线对齐行框包含那些框的长方形区域，会形成一行，叫做行框。行框的宽度有它的包含块和其中的浮动元素决定，高度的确定由行高度计算规则决定；行框的规则  如果几个行内框在水平方向上无法放入一个行框内，它们可以分配在两个或多个垂直堆叠的行框中（即行内框的分割）  行框在堆叠是没有垂直方向上的分割且永远不重叠；  行框的高度总是足够容纳所包含的所有框，不过他可能高于他包含的最高的框（例如，框对齐会引起基线对齐）  行框的左边接触到其包含块的左边，右边接触到其包含块的右边。总结  行内元素总是会应用IFC渲染规则；  行内元素会应用IFC规则渲染，譬如text-align可以用来居中等；  块框内部对于文本这类的匿名元素，会产生匿名行框包围，而行框内部就应用IFC渲染规则  行内框内部，对于那些行内元素，一样应用IFC渲染规则；  另外，inline-block，会在元素外层产生IFC（所以这个元素可以通过text-align水平居中），当然，它的内部则按照BFC规则渲染JS引擎解析过程另开一篇，JS解析与执行过程JavaScript 运行机制详解——Event Loop写在最后这篇大概写了一个礼拜，对基础问题的深挖更能弥补自身的不足，前端学习知识繁杂，只靠碎片化的知识而自己不加消化和理解，很难形成知识体系。通过对主干大方向的把握，在填充具体知识点。受益良多～✋✋参考  http://www.dailichun.com/2018/03/12/whenyouenteraurl.html  http://www.qnx.com/developers/docs/6.4.1/neutrino/getting_started/s1_procs.html  http://www.imweb.io/topic/58e3bfa845e5c13468f567d5  https://blog.csdn.net/sh435367384/article/details/79652159  https://segmentfault.com/a/1190000004093321?_ea=487081  https://www.cnblogs.com/shijianchuzhenzhi/p/6387013.html  https://blog.csdn.net/linsongbin1/article/details/54980801  how browers work  图解http  CSS的可视化格式模型]]></content>
      <categories>
        
          <category> Http </category>
        
      </categories>
      <tags>
        
          <tag> TCP </tag>
        
          <tag> IP </tag>
        
          <tag> Dom </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[ES6-箭头函数及定时器this指向]]></title>
      <url>/es6/2018/09/16/ES6-func/</url>
      <content type="text"><![CDATA[箭头函数注意点  函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。  不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。  不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。  不可以使用yield命令，因此箭头函数不能用作 Generator 函数。this  this对象的指向是可变的，但在箭头函数中，是固定的。绑定定义时所在的作用域，而不是指向运行时所在的作用域。          非箭头函数的this指向运行时调用它的对象，即foo。        var a=11;var foo={a:22,say:function(){  console.log(this.a)}}foo.say();//22;                      箭头函数的this是继承自父执行上下文中的this。箭头函数say本身在对象foo中，而foo的执行上下文this指向全局window。        var a=11;var foo={a:22,say:()=&gt;{  console.log(this.a)}}foo.say();//11;                       实际原因是箭头函数根本没有自己的this，导致内部的this就是外层代码块的this。正是因为它没有this，所以也就不能用作构造函数。// ES6function foo() {  setTimeout(() =&gt; {    console.log('id:', this.id);  }, 100);}// ES5function foo() {  var _this = this;  setTimeout(function () {    console.log('id:', _this.id);  }, 100);}定时器var num=11;function F(){    this.num=22;    this.getNum=function(){        console.log(this.num);    },    this.getNumLater=function(){        setTimeout(function(){            console.log(this.num);        },1000)    }}var foo=new F();foo.getNum(); //22foo.getNumLater(); //11问题原因setTimeout中函数内的this是指向了window对象，这是由于setTimeout()调用的代码运行在与所在函数完全分离的执行环境上。参考 MDN setTimeout解决方法  将当前this保存为一个变量    var num=11;function F(){ var _this=this; this.num=22; this.getNum=function(){     console.log(this.num); }, this.getNumLater=function(){     setTimeout(function(){         console.log(_this.num);     },1000) }}var foo=new F();foo.getNum(); //22foo.getNumLater(); //22        使用箭头函数，箭头函数的this指向外层（父级）调用者，也就是F();    function F(){ this.num=22; this.getNum=function(){     console.log(this.num); }, this.getNumLater=function(){     setTimeout(()=&gt;{         console.log(this.num);     },1000) }}var foo=new F();foo.getNum(); //22foo.getNumLater(); //22        利用bind。当被绑定函数执行时，bind方法会创建一个新函数，并将第一个参数作为新函数运行时的this。参考MDN bind    var num=11;function F(){ this.num=22; this.getNum=function(){     console.log(this.num); }, this.getNumLater=function(){     setTimeout(function(){         console.log(this.num);     }.bind(this),1000) }}var foo=new F();foo.getNum(); //22foo.getNumLater(); //22      ]]></content>
      <categories>
        
          <category> ES6 </category>
        
      </categories>
      <tags>
        
          <tag> ES6 </tag>
        
          <tag> 箭头函数 </tag>
        
          <tag> 定时器 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[JavaScript 运行机制详解——Event Loop]]></title>
      <url>/js%E5%9F%BA%E7%A1%80/2018/09/15/js-eventloop/</url>
      <content type="text"><![CDATA[JavaScript是非阻塞单线程语言JavaScript的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点.这时浏览器应该以哪个线程为准？任务队列单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。于是，所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；异步任务指的是，不进入主线程、而进入”任务队列”（task queue）的任务，只有”任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。具体来说，异步执行的运行机制如下。  所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。  主线程之外，还存在一个”任务队列”（task queue）。  只要异步任务有了运行结果，就在”任务队列”之中放置一个事件。  一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，  看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。  主线程不断重复上面的第三步。Event Loopconsole.log('script start');setTimeout(function() {  console.log('setTimeout');}, 0);console.log('script end');以上代码虽然 setTimeout 延时为 0，其实还是异步。这是因为 HTML5 标准规定这个函数第二个参数不得小于 4 毫秒，不足会自动增加。所以 setTimeout 还是会在 script end 之后打印。不同的任务源会被分配到不同的 Task 队列中，任务源可以分为 微任务（microtask） 和 宏任务（macrotask）。在 ES6 规范中，microtask 称为 jobs，macrotask 称为 task. 微任务包括 process.nextTick ，promise ，Object.observe ，MutationObserver宏任务包括 script ， setTimeout ，setInterval ，setImmediate ，I/O ，UI rendering 假设 macro-task队列包含任务: a1, a2 , a3 micro-task队列包含任务: b1, b2 , b3执行顺序为，首先执行marco-task队列开头的任务，也就是 a1 任务，执行完毕后，在执行micro-task队列里的所有任务，也就是依次执行b1, b2 , b3，执行完后清空micro-task中的任务，接着执行marco-task中的第二个任务，依次循环。  由此我们得到的执行顺序应该为：script(主程序代码)—&gt;process.nextTick—&gt;Promises…——&gt;setTimeout——&gt;setInterval——&gt;setImmediate——&gt; I/O——&gt;UI renderingconsole.log('script start');setTimeout(function() {  console.log('setTimeout');}, 0);new Promise((resolve) =&gt; {    console.log('Promise')    resolve()}).then(function() {  console.log('promise1');}).then(function() {  console.log('promise2');});console.log('script end');// script start =&gt; Promise =&gt; script end =&gt; // promise1 =&gt; promise2 =&gt; setTimeout这里要注意的一点在定义promise的时候，promise构造部分是同步执行的.setTimeout(function(){console.log(1)},0);new Promise(function(resolve,reject){   console.log(2);   resolve();}).then(function(){console.log(3)}).then(function(){console.log(4)});process.nextTick(function(){console.log(5)});console.log(6);//输出2,6,5,3,4,1参考  JavaScript 运行机制详解：再谈Event Loop(阮一峰)]]></content>
      <categories>
        
          <category> JS基础 </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[斐波那契数列]]></title>
      <url>/%E7%AE%97%E6%B3%95/2018/09/14/jianzhi-fb/</url>
      <content type="text"><![CDATA[斐波那契数列大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。n&lt;=39function Fibonacci(n){    if(n==0){        return 0;    }    if(n==1||n==2){        return 1;    }    var f1=1,f2=1,f3=0;    for(var i=3;i&lt;=n;i++){        f3=f1+f2;        f1=f2;        f2=f3;    }    return f3;}跳台阶一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。递归公式 $f(n)=f(n-1)+f(n-2)$function jumpFloor(number){    if(number&lt;=3){        return number;    }    var f1=2,f2=3,f3=0;    for(var i=4;i&lt;=number;i++){        f3=f1+f2;        f1=f2;        f2=f3;    }    return f3;}变态跳台阶一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。function jumpFloorII(number){    if(number==0||number==1){        return 1;    }    return 2* jumpFloorII(number-1);}矩形覆盖我们可以用21的小矩形横着或者竖着去覆盖更大的矩形。请问用n个21的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？$rect(n)=rect(n-1)+rect(n-2)$function rectCover(number){    if(number&lt;=2){        return number;    }    var f1=1,f2=2,f3=0;    for(var i=3;i&lt;=number;i++){        f3=f1+f2;        f1=f2;        f2=f3;    }    return f3;}]]></content>
      <categories>
        
          <category> 算法 </category>
        
      </categories>
      <tags>
        
          <tag> 剑指offer </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[二叉树相关]]></title>
      <url>/%E7%AE%97%E6%B3%95/2018/09/14/jianzhi-2cs/</url>
      <content type="text"><![CDATA[思路  二叉树多用递归思想，确定边界条件。  二叉树相关性质。重建二叉树输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。/* function TreeNode(x) {    this.val = x;    this.left = null;    this.right = null;} */function reConstructBinaryTree(pre, vin){    if(!pre||pre.length==0){        return;    }    var treeNode={        val:pre[0]    }    for(var i=0;i&lt;pre.length;i++){        if(vin[i]==pre[0]){            treeNode.left=reConstructBinaryTree(pre.slice(1,i+1), vin.slice(0,i));            treeNode.right=reConstructBinaryTree(pre.slice(i+1), vin.slice(i+1));        }    }    return treeNode}二叉树的镜像  /* function TreeNode(x) {      this.val = x;      this.left = null;      this.right = null;  } */  function Mirror(root)  {      if(!root){          return false;      }      var temp=root.left;      root.left=root.right;      root.right=temp;      Mirror(root.left);      Mirror(root.right);  }平衡二叉树输入一棵二叉树，判断该二叉树是否是平衡二叉树。二叉树的每个节点的左子树和右子树的深度不大于1/* function TreeNode(x) {    this.val = x;    this.left = null;    this.right = null;} */function IsBalanced_Solution(pRoot){    if(pRoot==null){        return true;    }    return Math.abs(deep(pRoot.left)-deep(pRoot.right))&lt;=1?true:false;}function deep(root){    if(!root){        return 0;    }    return Math.max(deep(root.left),deep(root.right))+1;}对称二叉树请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。/* function TreeNode(x) {    this.val = x;    this.left = null;    this.right = null;} */function isSymmetrical(pRoot){    return isSym(pRoot,pRoot);}function isSym(root1,root2){     if(root1 == null &amp;&amp; root2 == null){        return true;    }    if(root1 == null || root2 == null){        return false;    }    if(root1.val != root2.val){        return false;    }    return isSym(root1.left, root2.right) &amp;&amp; isSym(root1.right, root2.left);    }二叉搜索树的后序遍历序列输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。分治思想非递归也是一个基于递归的思想：左子树一定比右子树小，因此去掉根后，数字分为left，right两部分，right部分的最后一个数字是右子树的根他也比左子树所有值大，因此我们可以每次只看有子树是否符合条件即可。function VerifySquenceOfBST(sequence){    if(sequence.length==0){        return false;    }    var n=sequence.length;    var i=0;    while(n--){        while(sequence[i]&lt;sequence[n]){            i++        }        while(sequence[i]&gt;sequence[n]){            i++;        }        if(i&lt;n){            return false;        }        i=0;    }    return true;}]]></content>
      <categories>
        
          <category> 算法 </category>
        
      </categories>
      <tags>
        
          <tag> 剑指offer </tag>
        
          <tag> 二叉树 </tag>
        
          <tag> leetcode </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[leetcode3 无重复最长子串]]></title>
      <url>/%E7%AE%97%E6%B3%95/2018/09/13/leetcode3/</url>
      <content type="text"><![CDATA[题目Given a string, find the length of the longest substring without repeating characters.Examples:  Given “abcabcbb”, the answer is “abc”, which the length is 3.  Given “bbbbb”, the answer is “b”, with the length of 1.  Given “pwwkew”, the answer is “wke”, with the length of 3. Note that the answer must be a substring, “pwke” is a subsequence and not a substring.思路设置一个滑动窗口，两个指针i，j，i 遍历字符串，j 记录无重复子串的位置起点。map保存无重复字符，并更新其index。/** * @param {string} s * @return {number} */var lengthOfLongestSubstring = function(s) {    if(s==""){        return 0;    }    var maxL=0;    var list=new Map();    for(var i=0,j=0;i&lt;s.length;i++){        if(list.has(s[i])){            j=Math.max(j,list.get(s[i])+1);        }        list.set(s[i],i);        maxL=Math.max(maxL,i-j+1);    }    return maxL;}  ]]></content>
      <categories>
        
          <category> 算法 </category>
        
      </categories>
      <tags>
        
          <tag> leetcode </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[猫眼面经]]></title>
      <url>/%E9%9D%A2%E8%AF%95/2018/08/30/interview-maoyan/</url>
      <content type="text"><![CDATA[水平垂直居中布局  flex    .box{ display: flex; align-items: center;  /*垂直*/ justify-content: center; /*水平*/ height: 100vh; /*视口高度*/}        table    .box{ display: table;    /* 让div以表格的形式渲染 */ width: 100%; height: 100vh;}.content{ display: table-cell;  /* 让子元素以表格的单元格形式渲染 */ text-align: center; vertical-align: middle;}        relative+absolute    .box{ position: relative; height: 100vh;}.content{position: absolute;top:50%;left:50%;transform: translate(-50%,-50%);}      盒模型标准模型中，盒模型的宽高只是内容（content）的宽高，而在IE模型中盒模型的宽高是内容(content)+填充(padding)+边框(border)的总宽高。/* 标准模型 */box-sizing:content-box; /*IE模型*/box-sizing:border-box;  CSS-position  static 正常文档流，忽略left，top，right，bottom，z-index  relative 相对于原本位置的定义，对周围元素没有任何影响  absolute 脱离文档流，绝对定位，相对于 static 定位以外的第一个父元素进行定位。 元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。  fixed 相对于浏览器窗口，脱离文档流  sticky 粘性定位，该定位基于用户滚动的位置。它的行为就像 position:relative; 而当页面滚动   超出目标区域时，它的表现就像 position:fixed;它会固定在目标位置。元素未滚动，top不生效，margin有效。元素滚动：top有效，margin失效。块级、行内元素  块级元素 自动换行，可设置高度 div p h1~h6 ul ol dl li dd table hr blockquote address table menu pre header section aside footer  行内元素 span br a  em b i  strong sub sup  行块级元素 有内在尺寸，可设置高宽，无法自动换行 img  input  td  textareaUl增加多个Li  文档碎片documentFragment    var fragment=document.createDocumentFragment();var ul=document.getElementById("myList");var li=null;for(var i=0;i&lt;n,i++){  li=document.createElement("li");  li.appendChild(document.createTextNode("item"+(i+1)));  fragment.appendChild(li);}ul.appendChild(fragment);        innerHTML类型判断typeof 是一个一元运算，放在一个运算数之前，运算数可以是任意类型。它返回值是一个字符串，该字符串说明运算数的类型。包括：number、boolean、string、object、undefined、function等6种数据类型。typeof (null) //”object”instanceof 运算符用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性。语法：object instanceof constructorObject.prototype.toString.call(value) 方法去调用对象，得到对象的构造函数名。可以解决instanceof的跨框架问题，缺点是对用户自定义的类型，它只会返回[object Object]数组遍历//数组遍历,都不会修改数组中包含的值//对数组每一项运行给定的函数//every 如果该函数对每一项都返回true，则返回true//some 如果该函数对任一项返回true，则返回truevar nums=[1,2,4,5,2,8,9];var everyResult=nums.every(function(item,index,arr){    return(item&gt;2);})//falsevar someResult=nums.some(function(item,index,arr){    return(item&gt;2);})//truevar filterResult=nums.filter(function(item,index,arr){    return(item&gt;2)})//[4,5,8,9]var mapResult=nums.map(function(item,index,arr){    return item*2})//[2,4,8,10,4,16,18]nums.forEach(function(item,index,arr){    //执行某些操作})两个有序数组，一升一降，返回第k大思路最开始考虑的是两个数组合并为一个有序数组，通过数组下标index取得第k大，但空间复杂度较高。可以采用原地置换的方法，空间复杂$O(1)$。function findMax(a,b,k){	var maxK,n=0;	var i=a.length-1,j=0;	while(j&lt;a.length&amp;&amp;i&gt;=0){		if(a[i]&lt;b[j]){			maxK=b[j];			j++;			n++;		}else if(a[i]==b[j]){			j++;		}else{			maxK=a[i];			i--;			n++;		}		if(n==k){			return maxK;		}	}}字符串压缩 aaabbcaadd—a3b2c1a2d2思路这个题很简单了，遍历字符串记录前后相同字符出现的次数。 :smile:function compress(str){	if(!str||str.length==0){		return false;	}	str=str.trim();	var cur=str[0];	var marks='';	var count=1;	for(var i=0;i&lt;str.length;i++){		if(str[i]==cur){			count++;		}else{			marks+=cur+count;			cur=str[i];			count=1;		}	}	return marks+cur+count;}]]></content>
      <categories>
        
          <category> 面试 </category>
        
      </categories>
      <tags>
        
          <tag> CSS布局 </tag>
        
          <tag> DOM操作 </tag>
        
          <tag> 数组方法 </tag>
        
          <tag> 字符串 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[网络基础TCP/IP]]></title>
      <url>/http/2018/08/29/http-tcp-ip/</url>
      <content type="text"><![CDATA[TCP/IP协议族TCP/IP 是互联网相关的各类协议族的总称TCP/IP 的分层管理TCP/IP 协议族按层次分别分为以下4层：应用层、传输层、网络层和数据链路层。TCP/IP 协议族各层的作用如下。应用层应用层决定了向用户提供应用服务时通信的活动。TCP/IP 协议族内预存了各类通用的应用服务。比如FTP（File Transfer Protocol，文件传输协议)DNS（Domain Name System，域名系统）Telent（远程终端协议)SMTP（Simple Mail Transfer Protocol，简单邮件传输协议）HTTP（HyperText Transfer Protocal，超文本传输协议）传输层传输层对上层应用层，提供处于网络连接中的两台计算机之间的数据传输。在传输层有两个性质不同的协议：TCP（Transmission Control Protocol，传输控制协议）UDP（User Data Protocol，用户数据报协议）。TCPTCP为两台主机提供高可靠性的数据通信。它所做的工作包括把应用程序交给它的数据分成合适的小块交给下面的网络层，确认接收到的分组，设置发送最后确认分组的超时时钟等。由于运输层提供了高可靠性的端到端的通信，因此应用层可以忽略所有这些细节。为了提供可靠的服务，TCP采用了超时重传、发送和接收端到端的确认分组等机制。UDPUDP则为应用层提供一种非常简单的服务。它只是把称作数据报的分组从一台主机发送到另一台主机，但并不保证该数据报能到达另一端。一个数据报是指从发送方传输到接收方的一个信息单元（例如，发送方指定的一定字节数的信息）。UDP协议任何必需的可靠性必须由应用层来提供。网络层（又名网络互连层）网络层用来处理在网络上流动的数据包。数据包是网络传输的最小数据单位。该层规定了通过怎样的路径（所谓的传输路线）到达对方计算机，并把数据包传送给对方。与对方计算机之间通过多台计算机或网络设备进行传输时，网络层所起的作用就是在众多的选项内选择一条传输路线。在网络层有IP协议 ICMP（Internet Control Message Protocol，Internet控制报文协议）ARP（Address Resolution Protocol，地址解析协议）RARP（Reverse Address Resolution Protocol，反向地址转换协议）BOOTP（Bootstrap Protocol，引导程序协议）链路层（又名数据链路层，网络接口层）用来处理连接网络的硬件部分。包括控制操作系统、硬件的设备驱动、NIC（Network Interface Card，网络适配器，即网卡），及光纤等物理可见部分（还包括连接器等一切传输媒介）。硬件上的范畴均在链路层的作用范围之内。TCP/IP 通信传输流利用 TCP/IP 协议族进行网络通信时，会通过分层顺序与对方进行通信。发送端从应用层往下走，接收端则从链路层往上走。发送端在层与层之间传输数据时，每经过一层时必定会被打上一个该层所属的首部信息。反之，接收端在层与层传输数据时，每经过一层时会把对应的首部消去。这种把数据信息包装起来的做法称为封装（encapsulate参考  图解HTTP  一次完整的HTTP请求与响应涉及了哪些知识]]></content>
      <categories>
        
          <category> Http </category>
        
      </categories>
      <tags>
        
          <tag> TCP </tag>
        
          <tag> IP </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[防抖与节流]]></title>
      <url>/js%E5%9F%BA%E7%A1%80/2018/08/28/js-debounce-throttle/</url>
      <content type="text"><![CDATA[函数防抖(debounce)在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。  给按钮加函数防抖防止表单多次提交。  对于输入框连续输入进行AJAX验证时，用函数防抖能有效减少请求次数。  判断scroll是否滑到底部，滚动事件+函数防抖总的来说，适合多次事件一次响应的情况function debounce(fn, wait) {  var timer = null;  return function () {      var context = this      var args = arguments      if (timer) {          clearTimeout(timer);          timer = null;      }      timer = setTimeout(function () {          fn.apply(context, args)      }, wait)  }}函数节流(throttle)规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。  游戏中的刷新率  DOM元素拖拽  Canvas画笔功能总的来说，适合大量事件按时间做平均分配触发。function throttle(fn, gapTime) {  let _lastTime = null;  return function () {    let _nowTime = + new Date()    if (_nowTime - _lastTime &gt; gapTime || !_lastTime) {      fn();      _lastTime = _nowTime    }  }}]]></content>
      <categories>
        
          <category> JS基础 </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[阿里面经]]></title>
      <url>/%E9%9D%A2%E8%AF%95/2018/08/20/interview-ali/</url>
      <content type="text"><![CDATA[两栏布局  float+margin-left    aside{ background: yellow; width: 200px; float: left;}div{ margin-left: 210px;/*大于aside的宽度*/ width: auto; background: red;}        float+overflow：hidden（形成BFC）    div{ overflow:hidden; width: auto; background: red; height: 400px;}        flex    body{ display: flex;}aside{ background: yellow; flex:0 0 200px;}div{ flex:1 1 auto; background: red;}        grid    body{  display: grid;  grid-template-columns: 200px auto;}        table    aside{   width: 200px;   display: table-cell;   background: yellow;}div{ display: table-cell; background: red;}      meta标签元素可提供有关页面的元信息（meta-information）            属性      值      描述                  charset（#）      character_set      定义文档的字符编码。              content      text      定义与 http-equiv 或 name 属性相关的元信息。              http-equiv      content-typ edefault-style refresh      把 content 属性关联到 HTTP 头部。              name      application-nam eauthor description generator keywords      把 content 属性关联到一个名称。              scheme      format/URI      HTML5不支持。定义用于翻译 content 属性值的格式。      name属性name属性主要用于描述网页，与之对应的属性值为content，content中的内容主要是便于搜索引擎机器人查找信息和分类信息用的。meta标签的name属性语法格式是：&lt;meta name="参数" content="具体的参数值"&gt;。其中name属性主要有以下几种参数：Keywords（关键字）说明：keywords用来告诉搜索引擎你网页的关键字是什么。举例 &lt;meta name ="keywords" content="science human culture"&gt;description（网站内容描述)说明：description用来告诉搜索引擎你的网站主要内容。 网站内容描述（description）的设计要点:  网页描述为自然语言而不是罗列关键词（与keywords设计正好相反）；  尽可能准确地描述网页的核心内容，通常为网页内容的摘要信息，也就是希望搜索引擎在检索结果中展示的摘要信息；  网页描述中含有有效关键词；  网页描述内容与网页标题内容有高度相关性；  网页描述内容与网页主体内容有高度相关性；  网页描述的文字不必太多，一般不超过搜索引擎检索结果摘要信息的最多字数（通常在100中文字之内，不同搜索引擎略有差异）。robots（机器人向导）说明：robots用来告诉搜索机器人哪些页面需要索引，哪些页面不需要索引。content的参数有all,none,index,noindex,follow,nofollow。默认是all。举例 &lt;meta name="robots" content="none"&gt;author（作者）说明：标注网页的作者http-equiv属性http-equiv顾名思义，相当于http的文件头作用，它可以向浏览器传回一些有用的信息，以帮助正确和精确地显示网页内容，与之对应的属性值为content，content中的内容其实就是各个参数的变量值。meta标签的http-equiv属性语法格式是：&lt;meta http-equiv="参数" content="参数变量值"&gt; 其中http-equiv属性主要有以下几种参数：Expires（期限）说明：可以用于设定网页的到期时间。一旦网页过期，必须到服务器上重新传输。用法：&lt;meta http-equiv="expires" content="Fri,12 Jan 2001 18:18:18 GMT"&gt;注意：必须使用GMT的时间格式。Pragma(cache模式）说明：禁止浏览器从本地计算机的缓存中访问页面内容。用法：&lt;meta http-equiv="Pragma" content="no-cache"&gt;注意：这样设定，访问者将无法脱机浏览。Refresh（刷新）说明：自动刷新并转到新页面。用法：&lt;meta http-equiv="Refresh" content="2;URL"&gt;（注意后面的分号，分别在秒数的前面和网址的后面，URL可为空）注意：其中的2是指停留2秒钟后自动刷新到URL网址。Set-Cookie(cookie设定）说明：如果网页过期，那么存盘的cookie将被删除。用法：&lt;meta http-equiv="Set-Cookie" content="cookievalue=xxx; expires=Friday,12-Jan-2001 18:18:18 GMT; path=/"&gt;注意：必须使用GMT的时间格式。Window-target（显示窗口的设定）说明：强制页面在当前窗口以独立页面显示。用法：&lt;meta http-equiv="Window-target" content="_top"&gt;注意：用来防止别人在框架里调用自己的页面。content-Type（显示字符集的设定）说明：设定页面使用的字符集。用法：&lt;meta http-equiv="content-Type" content="text/html; charset=gb2312"&gt;content-Language（显示语言的设定）用法：&lt;meta http-equiv="Content-Language" content="zh-cn" /&gt;功能  帮助主页被各大搜索引擎登录  定义页面的使用语言  自动刷新并指向新的页面put/post区别最根本的区别就是：POST方法不是幂等的，而PUT方法则有幂等性。一个幂等操作的特点就是其任意多次执行所产生的影响均与依次一次执行的影响相同。POST在请求的时候，服务器会每次都创建一个文件，但是在PUT方法的时候只是简单地更新，而不是去重新创建。因此PUT是幂等的。假如我们发送两个/blog/post/Sample请求，服务器端是什么样的行为？如果产生了两个博客帖子，那就说明这个服务不是idempotent的，因为多次使用产生了副作用了嘛；如果后一个请求把第一个请求覆盖掉了，那这个服务就是idempotent的。前一种情况，每次返回结果不一样的时候，应该使用POST方法，后一种情况，应该使用PUT方法。http状态码  202状态码：服务器已接受请求，但尚未处理；  301状态码：被请求的资源已永久移动到新位置。服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。永久重定向  302状态码：请求的资源临时从不同的URI响应请求，但请求者应继续使用原有位置来进行以后的请求。暂时重定向  304自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。 如果网页自请求者上次请求后再也没有更改过，您应将服务器配置为返回此响应(称为 If-Modified-Since HTTP 标头)。  401状态码：请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。  403状态码：服务器已经理解请求，但是拒绝执行它。与401响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交。  404状态码：请求失败，请求所希望得到的资源未被在服务器上发现。没有信息能够告诉用户这个状况到底是暂时的还是永久的。假如服务器知道情况的话，应当使用410状态码来告知旧资源因为某些内部的配置机制问题，已经永久的不可用，而且没有任何可以跳转的地址。404这个状态码被广泛应用于当服务器不想揭示到底为何请求被拒绝或者没有其他适合的响应可用的情况下。  500状态码：服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。一般来说，这个问题都会在服务器的程序码出错时出现。  503状态码：由于临时的服务器维护或者过载，服务器当前无法处理请求。通常，这个是暂时状态，一段时间会恢复。跨域JSONP利用&lt;script&gt;标签没有跨域限制的漏洞，通过&lt;script&gt;标签指向一个需要访问的地址并提供一个回调函数来接收数据当需要通讯时。JSONP 使用简单且兼容性不错，但是只限于 get 请求。&lt;script src="http://domain/api?param1=a&amp;param2=b&amp;callback=jsonp"&gt;&lt;/script&gt; 在开发中可能会遇到多个 JSONP 请求的回调函数名是相同的，这时候就需要自己 封装一个 JSONP，以下是简单实现。function jsonp(url, jsonpCallback, success) {	let script = document.createElement("script");	script.src = url;	script.async = true;	script.type = "text/javascript";	window[jsonpCallback] = function(data) {		success &amp; success(data);	};	document.body.appendChild(script);}jsonp(	"http://xxx",	"callback",	function(value) {		console.log(value);	}); CORS浏览器会自动进行 CORS 通信，实现CORS通信的关键是后端。只要后端实现了 CORS，就实现了跨域。 服务端设置 Access-Control-Allow-Origin 就可以开启 CORS。 该属性表示哪些 域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。document.domain该方式只能用于二级域名相同的情况下，比如 a.test.com 和 b.test.com 适用于 该方式。 只需要给页面添加 document.domain = ‘test.com’ 表示二级域名都相同就可以实现跨域postMessage这种方式通常用于获取嵌入页面中的第三方页面数据。一个页面发送消息，另一个页面判断来源并接收消息 。// 发送消息端window.parent.postMessage('message', 'http://test.com'); // 接收消息端var mc = new MessageChannel(); mc.addEventListener('message', (event) =&gt; { 	var origin = event.origin || event.originalEvent.origin;	if (origin === 'http://test.com') {		console.log('验证通过')	} }); 数组去重  新建一新数组，遍历传入数组，值不在新数组就push进该新数组中（IE8以下不支持数组的indexOf方法）    function uniq1(arr){ var temp=[]; for(var i=0;i&lt;arr.length;i++){     if(temp.indexOf(arr[i])==-1){         temp.push(arr[i]);     } } return temp;}        对象键值对该方法执行的速度比其他任何方法都快， 就是占用的内存大一些。注意点：判断是否为js对象键时，会自动对传入的键执行toString()    function uniq2(arr){ var obj={},r=[],type,val; for(var i=0;i&lt;arr.length;i++){     val=arr[i];     type=typeof val;     if(!obj[val]){         obj[val]=[type];         r.push(val);     }else if(obj[val].indexOf(type)&lt;0){         obj[val].push(type);         r.push(val);     } } console.log(obj); return r;}        ES6数组去重（无法判断对象重复）向 Set 加入值的时候，不会发生类型转换，所以 5 和 ‘5’ 是两个不同的值。 Set 内部判断两个值是否相同，使用的算法是 “Same-value equality”，它类似于精确相等运算符（===）。主要的区别是 NaN等于自身，而精确运算符认为 NaN 不等于自身。两个对象总是不相等的，所以无法达到对象重复去重    function uniq3(arr){ return Array.from(new Set(arr));}        排序后遍历数组    function uniq4(arr){ var temp=[arr[0]]; arr.sort(); console.log(arr); for(var i=1;i&lt;arr.length;i++){     if(arr[i]!==temp[temp.length-1]){         temp.push(arr[i]);     } } return temp;}        map 值-值    function uniq5(arr){ var map=new Map(); for(var i=0;i&lt;arr.length;i++){     var temp=arr[i];     if(!map.has(temp)){         map.set(temp,1);     }else{         continue;     } } console.log(map) return [...map.keys()];}        ES6 Generate    vue双向绑定    vue生命周期  ]]></content>
      <categories>
        
          <category> 面试 </category>
        
      </categories>
      <tags>
        
          <tag> CSS布局 </tag>
        
          <tag> Http </tag>
        
          <tag> 数组方法 </tag>
        
          <tag> ES6 </tag>
        
          <tag> Vue </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Dom节点操作常用方法]]></title>
      <url>/js%E5%9F%BA%E7%A1%80/2018/08/19/dom-operate/</url>
      <content type="text"><![CDATA[访问/获取节点document.getElementById(id)　　　　　　　　    //返回对拥有指定id的第一个对象进行访问document.getElementsByName(name)　　　　　　  //返回带有指定名称的节点集合　　 document.getElementsByTagName(tagname)　　   //返回带有指定标签名的对象集合　 document.getElementsByClassName(classname)  //返回带有指定class名称的对象集合 创建节点/属性document.createElement(eName);　　   //创建一个节点document.createAttribute(attrName); //对某个节点创建属性document.createTextNode(text);　　　 //创建文本节点添加节点document.insertBefore(newNode,referenceNode)　 //在某个节点前插入节点parentNode.appendChild(newNode)　　　　　　　　  //给某个节点添加子节点复制节点cloneNode(true | false)　//复制某个节点  参数：是否复制原节点的所有属性删除节点parentNode.removeChild(node);　　//删除某个节点的子节点 node是要删除的节点注意：为了保证兼容性，要判断元素节点的节点类型(nodeType)，若nodeType==1，再执行删除操作。通过这个方法，就可以在 IE和 Mozilla 完成正确的操作。nodeType 属性可返回节点的类型.最重要的节点类型是：            元素类型      节点类型                  元素element      1              属性attr      2              文本text      3              注释comments      8              文档document      9      修改文本节点            方法      作用                  appendData(data)      将data加到文本节点后面              deleteData(start,length)      将从start处删除length个字符              insertData(start,data)      在start处插入字符,start的开始值是0              replaceData(start,length,data)      在start处用data替换length个字符              splitData(offset)      在offset处分割文本节点              substringData(start,length)      从start处提取length个字符      属性操作getAttribute(name)　　　　//通过属性名称获取某个节点属性的值setAttribute(name,value) //修改某个节点属性的值removeAttribute(name)    //删除某个属性查找节点parentObj.firstChild　　//如果节点为已知节点的第一个子节点就可以使用这个方法。此方法可以递归进行使用 parentObj.firstChild.firstChild.....parentObj.lastChild　　 //获得一个节点的最后一个节点，与firstChild一样也可以进行递归使用 parentObj.lastChild.lastChild.....parentObj.childNodes   //获得节点的所有子节点，然后通过循环和索引找到目标节点获取相邻的节点curtNode.previousSibling  //获取已知节点的相邻的上一个节点curtNode.nextSlbling　    //获取已知节点的下一个节点 获取父节点childNode.parentNode　　//得到已知节点的父节点 替换节点replace(newNode,oldNode)]]></content>
      <categories>
        
          <category> JS基础 </category>
        
      </categories>
      <tags>
        
          <tag> Dom </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Http缓存总结]]></title>
      <url>/http/2018/08/18/http-cache/</url>
      <content type="text"><![CDATA[]]></content>
      <categories>
        
          <category> Http </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[猿辅导面经]]></title>
      <url>/%E9%9D%A2%E8%AF%95/2018/08/17/interview-yfd/</url>
      <content type="text"><![CDATA[http请求头  Accept：告诉服务器，客户端支持的数据类型。  Accept-Charset：告诉服务器，客户端采用的编码。  Accept-Encoding：告诉服务器，客户机支持的数据压缩格式。  Accept-Language：告诉服务器，客户机的语言环境。  Host：客户机通过这个头告诉服务器，想访问的主机名。  If-Modified-Since:客户机通过这个头告诉服务器，资源的缓存时间。  Referer:客户机通过这个头告诉服务器，它是从哪个资源来访问服务器的。（一般用于防盗链  User-Agent:客户机通过这个头告诉服务器，客户机的软件环境。  Cookie：客户机通过这个头告诉服务器，可以向服务器带数据。  Connection：客户机通过这个头告诉服务器，请求完后是关闭还是保持链接。  Date：客户机通过这个头告诉服务器，客户机当前请求时间。http状态码            状态码      响应类别      响应类别                  1XX      信息性状态码（Informational）      服务器正在处理请求              2XX      成功状态码（Success）      请求已正常处理完毕              3XX      重定向状态码（Redirection）      需要进行额外操作以完成请求              4XX      客户端错误状态码（Client Error）      客户端原因导致服务器无法处理请求              5XX      服务器错误状态码（Server Error）      服务器原因导致处理请求出错        200 OK 请求正常处理完毕  204 No Content 请求成功处理，没有实体的主体返回  206 Partial Content GET范围请求已成功处理  301 Moved Permanently 永久重定向，资源已永久分配新URI  302 Found 临时重定向，资源已临时分配新URI  303 See Other 临时重定向，期望使用GET定向获取  304 Not Modified 发送的附带条件请求未满足  307 Temporary Redirect 临时重定向，POST不会变成GET  400 Bad Request 请求报文语法错误或参数错误  401 Unauthorized 需要通过HTTP认证，或认证失败  403 Forbidden 请求资源被拒绝  404 Not Found 无法找到请求资源（服务器无理由拒绝）  500 Internal Server Error 服务器故障或Web应用故障  503 Service Unavailable 服务器超负载或停机维护一个完整的URL假设这是一个url地址http://localhost:8080/a/b/c?a=1&amp;b=2#abc，里面包含的部分：  protocol: ‘http:’,//协议  host: ‘localhost:8080’,  port: ‘8080’,//端口  hostname: ‘localhost’,域名  hash: ‘#abc’,锚点  search: ‘?a=1&amp;b=2’ 等于 ?query: ‘a=1&amp;b=2’,  pathname: ‘/a/b/c’,  path: ‘/a/b/c?a=1&amp;b=2’,  href: ‘http://localhost:8080/a/b/c?a=1&amp;b=2#abc’获得URL中key对应的val值function getVal(url,key){	var start=url.indexOf("?");	var end=url.indexOf("#");	if(start&lt;0){		return null;	}	var query=end&lt;0?url.slice(start+1):url.slice(start+1,end);	var pairs=query.split("&amp;");	var args={};	for(var i=0;i&lt;pairs.length;i++){		var pos=pairs[i].indexOf("=");		if(pos==-1){			continue;		}		var argname=pairs[i].substring(0,pos);		var value=decodeURIComponent(pairs[i].substring(pos+1));		args[argname]=value;	}	return args[key];}js小数相加function add(){	var args=arguments,	    d=0,//小数位数;	    sum=0;	for(var key in args){ //遍历所有参数，取最大小数位数		var str=""+args[key];		if(str.indexOf(".")!=-1){			var temp=str.split(".")[1].length;			d=d&lt;temp?temp:d;		}	}	var m=Math.pow(10,d);	for(var key in args){		sum+=args[key]*m;	}	return sum/m;}a-z对应1-26，输入123输出abc，aw，lcfunction splitNumber(num){	var obj={		1:"a",		2:"b",		3:"c",		12:"l",		23:"w",	}	var res=[];	var temp=[];	var str="";	for(var i=1;i&lt;num.length;i++){		temp.push(num.substring(0,i),num.substring(i));	}	for(var j=0;j&lt;temp.length;j+=2){		res.push(obj[temp[j]]+obj[temp[j+1]]);	}	var str="";	for(var k=0;k&lt;num.length;k++){		str+=obj[num.charAt(k)];	}	res.push(str);	return res;	}]]></content>
      <categories>
        
          <category> 面试 </category>
        
      </categories>
      <tags>
        
          <tag> Http </tag>
        
          <tag> 数组方法 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
</search>
