---
title: 网易2018校招编程合集
description:
categories: 算法
tags:
- 网易
- 动态规划
- leetcode
---
题目来源于牛客网，[网易2018校园招聘编程题真题集合](https://www.nowcoder.com/test/6910869/summary)。

### 魔法币  
#### 题目
小易准备去魔法王国采购魔法神器,购买魔法神器需要使用魔法币,但是小易现在一枚魔法币都没有,但是小易有两台魔法机器可以通过投入x(x可以为0)个魔法币产生更多的魔法币。
魔法机器1:如果投入x个魔法币,魔法机器会将其变为2x+1个魔法币
魔法机器2:如果投入x个魔法币,魔法机器会将其变为2x+2个魔法币
小易采购魔法神器总共需要n个魔法币,所以小易只能通过两台魔法机器产生恰好n个魔法币,小易需要你帮他设计一个投入方案使他最后恰好拥有n个魔法币。   
输入描述:
>输入包括一行,包括一个正整数n(1 ≤ n ≤ 10^9),表示小易需要的魔法币数量。


输出描述:
>输出一个字符串,每个字符表示该次小易选取投入的魔法机器。其中只包含字符'1'和'2'。  
 
#### 思路
这个很简单啦，机器1产生奇数，机器2产生偶数，从n按奇偶不断回推到0即可。
````javascript
function deal(n) {
    var res=[];
    while(n){
        if(n%2==0){
            res.push(2);
            n=(n-2)/2;
        }else{
            res.push(1);
            n=(n-1)/2;
        }
    }
    return (res.reverse().join(""));
}
````  

### 相反数  
#### 题目
为了得到一个数的"相反数",我们将这个数的数字顺序颠倒,然后再加上原先的数得到"相反数"。例如,为了得到1325的"相反数",首先我们将该数的数字顺序颠倒,我们得到5231,之后再加上原先的数,我们得到5231+1325=6556.如果颠倒之后的数字有前缀零,前缀零将会被忽略。例如n = 100, 颠倒之后是1.   
输入描述:
>输入包括一个整数n,(1 ≤ n ≤ 10^5)  

输出描述:
>输出一个整数,表示n的相反数

#### 思路
太简单了...水题 :see_no_evil:
````javascript
function deal(str) {
    var num1=parseInt(str);
    var restr=str.split("").reverse().join("");
    var num2=parseInt(restr);
    return (num1+num2);
}
````  

### 字符串碎片  
#### 题目
一个由小写字母组成的字符串可以看成一些同一字母的最大碎片组成的。例如,"aaabbaaac"是由下面碎片组成的:'aaa','bb','c'。牛牛现在给定一个字符串,请你帮助计算这个字符串的所有碎片的平均长度是多少。
输入描述:
>输入包括一个字符串s,字符串s的长度length(1 ≤ length ≤ 50),s只含小写字母('a'-'z')

输出描述:
>输出一个整数,表示所有碎片的平均长度,四舍五入保留两位小数。

>如样例所示: s = "aaabbaaac"
所有碎片的平均长度 = (3 + 2 + 3 + 1) / 4 = 2.25    

#### 思路  
碎片的平均长度=字符串长度/相同字母团构成的字符串的个数，通过遍历字符串比较前后两个位置字符是否相等，记录去重长度。
````javascript
function deal(str) {
    var num=1;
    var temp=str[0];
    for(var i=1;i<str.length;i++){
        if(str[i]!=temp){
            num++;
        }
        temp=str[i];
    }
    return ((str.length/num).toFixed(2));
}
````

### 游历魔法王国
#### 题目
魔法王国一共有n个城市,编号为0~n-1号,n个城市之间的道路连接起来恰好构成一棵树。
小易现在在0号城市,每次行动小易会从当前所在的城市走到与其相邻的一个城市,小易最多能行动L次。
如果小易到达过某个城市就视为小易游历过这个城市了,小易现在要制定好的旅游计划使他能游历最多的城市,请你帮他计算一下他最多能游历过多少个城市(注意0号城市已经游历了,游历过的城市不重复计算)。   

输入描述:
>输入包括两行,第一行包括两个正整数n(2 ≤ n ≤ 50)和L(1 ≤ L ≤ 100),表示城市个数和小易能行动的次数。
第二行包括n-1个整数parent[i](0 ≤ parent[i] ≤ i), 对于每个合法的i(0 ≤ i ≤ n - 2),在(i+1)号城市和parent[i]间有一条道路连接。


输出描述:
>输出一个整数,表示小易最多能游历的城市数量。

#### 思路
首先考虑二叉树的深度遍历，但数组序列化为二叉树没写出来。题目重点在第二行，
即0——i-1的节点各自对应的父节点，且父节点值<字节点。  
用**动态规划**求解。递归方程`dp[i]=dp[i-1]+1`
分两种情况，最长树链maxLen，步数L  
(1) L<=MaxLen,城市数量(L+1)    
(2) L>MaxLen,城市数量Math.min(n, maxLen + (L - maxLen) / 2 + 1)    
````javascript
function deal(n,l,arr){
    var maxLen=0;
    var dp=[];
    dp[0]=0;
    for(var i=0;i<n-1;i++){
        dp[i+1]=dp[arr[i]]+1;
        maxLen=Math.max(dp[i+1],maxLen);
    }
    if(l<=maxLen){
        return (l+1);
    }else{
        return Math.min(n,maxLen + Math.floor((l- maxLen) / 2) + 1)
    }
}
````   
 
### 重排数列
#### 题目  
小易有一个长度为N的正整数数列A = {A[1], A[2], A[3]..., A[N]}。
牛博士给小易出了一个难题:
对数列A进行重新排列,使数列A满足所有的A[i] * A[i + 1](1 ≤ i ≤ N - 1)都是4的倍数。
小易现在需要判断一个数列是否可以重排之后满足牛博士的要求。   
输入描述:
>输入的第一行为数列的个数t(1 ≤ t ≤ 10),
接下来每两行描述一个数列A,第一行为数列长度n(1 ≤ n ≤ 10^5)
第二行为n个正整数A[i](1 ≤ A[i] ≤ 10^9)

输出描述:
>对于每个数列输出一行表示是否可以满足牛博士要求,如果可以输出Yes,否则输出No。

#### 思路  
找规律题～～但考虑不要太过详细。数列满足要求有以下三种情况  
(1) 全部能被2整除  
(2) 能被4整除的数>=数列个数的一半，剩下的数插空法补足数列  
(3) 奇数的个数-1<=能被4整除的个数，一个能被4整除的数最多带一个奇数，即（能被2整除+能被4整除）>=数列长度。  
````javascript
function deal(arr){
    var count4=0,count2=0;
    for(var i=0;i<arr.length;i++){
        if(arr[i]%4==0){
            count4++;
        }
        if(arr[i]%2==0){
            count2++;
        }
    }
    if(count2==arr.length||count4>=parseInt(arr.length/2)||count2+count4>=arr.length){
        return 'Yes';
    }else{
        return 'No';
    }
}
````   
 
### 最长公共子括号序列
#### 题目  
小易给出一个合法的括号匹配序列s,小易希望你能找出具有以下特征的括号序列t:  
1、t跟s不同,但是长度相同  
2、t也是一个合法的括号匹配序列  
3、LCS(s, t)是满足上述两个条件的t中最大的
因为这样的t可能存在多个,小易需要你计算出满足条件的t有多少个。  
如样例所示: s = "(())()",跟字符串s长度相同的合法括号匹配序列有:
"()(())", "((()))", "()()()", "(()())",其中LCS( "(())()", "()(())" )为4,其他三个都为5,所以输出3.   

输入描述:
>输入包括字符串s(4 ≤ |s| ≤ 50,|s|表示字符串长度),保证s是一个合法的括号匹配序列。


输出描述:
>输出一个正整数,满足条件的t的个数。

#### 思路
这道题的题干太长了，但其实没那么复杂。根据题意，要想使得 LCS 最大，
删去任意一个字符即可获得 LCS = |s| - 1 ，再把该字符插到与原来不同的任意位置可以维持原长度，而不影响 LCS 的计算。 
````javascript
function deal(str){
	var res=new Set();
	for(var i=str.length-2;i>0;i--){
	    var arr=str.split("")
	    var temp=arr[i];
	    arr.splice(i,1);
	    for(var j=arr.length-1;j>=0;j--){
	        arr.splice(j,0,temp);
	        if(vaild(arr)){
	            res.add(arr.join(""))
	        }
	        arr.splice(j,1)
	    }
	}
	if(res.has(str)){
		res.delete(str);
	}
	return res.size;
}
function vaild(a){
    var stack=[];
    for(var k=0;k<a.length;k++){
        if(a[k]=="("){
            stack.push("(");
        }else{
            stack.pop();
        }
    }
    return stack.length==0;
}
````

参考[Leetcode22 括号生成](https://leetcode-cn.com/problems/generate-parentheses/description/)
>给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合  

````javascript
/**
 * @param {number} n
 * @return {string[]}
 */
var generateParenthesis = function(n) {
    var ans=new Set();   
    generate(n,0,0,"",ans);
    return Array.from(ans);
};
function generate(n,left,right,ret,ans){
    if(left+right==2*n){
        ans.add(ret);
        return ;
    }
    if(left<n){
        generate(n,left+1,right,ret+"(",ans)
        if(right<left){
            generate(n,left,right+1,ret+")",ans);
        }
    }else{
        generate(n,left,right+1,ret+")",ans);
    }
}
````



### 合唱
#### 题目
小Q和牛博士合唱一首歌曲,这首歌曲由n个音调组成,每个音调由一个正整数表示。
对于每个音调要么由小Q演唱要么由牛博士演唱,对于一系列音调演唱的难度等于所有相邻音调变化幅度之和, 例如一个音调序列是8, 8, 13, 12, 那么它的难度等于|8 - 8| + |13 - 8| + |12 - 13| = 6(其中||表示绝对值)。
现在要对把这n个音调分配给小Q或牛博士,让他们演唱的难度之和最小,请你算算最小的难度和是多少。  
如样例所示: 小Q选择演唱{5, 6}难度为1, 牛博士选择演唱{1, 2, 1}难度为2,难度之和为3,这一个是最小难度和的方案了。   
输入描述:
>输入包括两行,第一行一个正整数n(1 ≤ n ≤ 2000) 第二行n个整数v[i](1 ≤ v[i] ≤ 10^6), 表示每个音调。  

输出描述:
>输出一个整数,表示小Q和牛博士演唱最小的难度和是多少。

#### 思路
#### 贪心算法  
第一个人唱低音，第二个人唱高音，先把数组排个序，然后选择前一部分作为低音，后一部分作为高音。
分割的标准是两个元素间隔最大的地方。不过这样做只能通过60%的样例。
#### 动态规划  
(1)dp[i][j]（永远有i > j）表示某一个人最近唱的音为第i个，另一个人最近唱的是第j个时最小的难度  
(2)由于只由一个人唱完肯定不是最优解。因此先在一个for循环内确定以下两种情况的初值
dp[i][0]：第二个人唱第一个音，第一个人唱后面所有音
dp[i][i-1]：第一个人唱最近的一个音，第二个人唱前面所有音  
(3)dp[i][j]转移方程,每当交换唱歌次序，两人最近一次唱的音符一定是相邻的，所以底下分相邻和不相邻讨论：  
- 当j == i - 1，即交换唱歌次序，dp[i][i-1]时，表明第一个人上一个音可能在第k个音（0 <= k < i-1）,由唱了最近的第i个，第二个人仍然留在第i-1个音。
dp[i][i-1] = 对所有k求min(dp[i-1][k] + abs(arr[i] - arr[k]) ) 其中（0 <= k < i-1）
- 当j < i - 1，即不交换唱歌次序时，只可能由唱到i-1音符的人续唱
dp[i][j] = dp[i-1][j] + abs(arr[i] - arr[i-1])    

(4)最后求出所有dp[len-1][]里的最小值即为全局最优解  

### 射击游戏
#### 题目  
小易正在玩一款新出的射击游戏,这个射击游戏在一个二维平面进行,小易在坐标原点(0,0),平面上有n只怪物,每个怪物有所在的坐标(x[i], y[i])。小易进行一次射击会把x轴和y轴上(包含坐标原点)的怪物一次性消灭。
小易是这个游戏的VIP玩家,他拥有两项特权操作:
1、让平面内的所有怪物同时向任意同一方向移动任意同一距离
2、让平面内的所有怪物同时对于小易(0,0)旋转任意同一角度
小易要进行一次射击。小易在进行射击前,可以使用这两项特权操作任意次。
小易想知道在他射击的时候最多可以同时消灭多少只怪物,请你帮帮小易。  
如样例所示:
![](https://uploadfiles.nowcoder.net/images/20170908/906271_1504858526319_5919175DAEBEFEF2DD7B449C60B277DF)
所有点对于坐标原点(0,0)顺时针或者逆时针旋转45°,可以让所有点都在坐标轴上,所以5个怪物都可以消灭。  

输入描述:
>输入包括三行。
第一行中有一个正整数n(1 ≤ n ≤ 50),表示平面内的怪物数量。
第二行包括n个整数x[i](-1,000,000 ≤ x[i] ≤ 1,000,000),表示每只怪物所在坐标的横坐标,以空格分割。
第二行包括n个整数y[i](-1,000,000 ≤ y[i] ≤ 1,000,000),表示每只怪物所在坐标的纵坐标,以空格分割。


输出描述:
>输出一个整数表示小易最多能消灭多少只怪物。



### 挖个坑  
后两道感觉挺难的，呜呜呜先参考大神思路，代码再再补上。:sob: :sob: :sob:
