---
title: 从输入URL到页面加载的过程
description:
categories: Http
tags:
- TCP
- IP
- Dom
---  
## 前言  
经典面试题，但方方面面的很多东西，要答好也不简单。通过对这道题的分析，希望梳理出一个前端向的知识体系 :dancers: :dancers: :dancers:  
主要包括：  
- 从浏览器接收url到开启网络请求线程  
- 开启网络线程到发出一个完整的http请求
- 从服务器接收到请求到对应后台接收到请求
- 后台和前台的http交互
- 缓存问题，[http的缓存]({{site.url}}/http/2018/08/18/http-cache/)
- 解析页面流程
- CSS的可视化格式模型
- JS引擎解析过程  

## 从浏览器接收url到开启网络请求线程  
### 线程与进程  
进程和线程的对比网上大多是概念性的解释，要真正理解进程与线程中的时间片和其他精彩的“调度概念”之前，
建立一个类比，首先来说明线程和进程是如何工作的。
#### 作为房子  
使用常规的日常对象 - 房子来对进程和线程进行类比。  
房子实际上是一个容器，具有某些属性（例如占地面积，卧室数量等）。房子本身并没有主动做 任何事情 - 这是一个被动的对象。这实际上是一个进程。    
住在房子里的人是活跃的对象 - 他们是使用各种房间，看电视，做饭，洗澡等等。线程的行为方式。
#### 单线程  
如果你住在自己的房子里，那么你可以在任何时间做任何事，因为房子里没有其他人。
你可以打开电视，使用洗手间，吃晚餐等等，只需要继续操作即可。
#### 多线程
当把另一个人加入房子时，你不能在任何一个点上进入洗手间，你需要先检查一下，洗手间有没有人。  
如果有两个负责任的成年人住在一个​​房子里，一般来说可以合理地对“安全”松懈，你知道另一个成年人会尊重你的空间，不会让厨房着火等等。
现在，把几个孩子扔进去，事情变得更加复杂。 
#### 回到线程与进程  
在macOS系统中，可以打开活动监视器查看后台进程与线程，和内存资源信息和CPU占有率。  
![]({{site.url}}/assets/images/2018-9-17-http-url/MacProcesses.jpg)  
**进程**  
进程是一个具有一定独立功能的程序在一个数据集上的一次动态执行的过程，是操作系统进行资源分配和调度的一个独立单位，是应用程序运行的载体。  
**线程**  
由于进程对于CPU的使用是轮流的，那么就存在进程的切换，但是由于现在的程序都比较大，切换的开销很大会浪费CPU的资源，于是就发明了线程，把一个大的进程分解成多个线程共同执行。  
**区别**  
- 进程是操作系统分配资源的最小单位，线程是程序执行的最小单位。
- 一个进程由一个或多个线程组成，线程是一个进程中代码的不同执行路线；
- 进程之间相互独立，但同一进程下的各个线程之间共享程序的内存空间(包括代码段、数据集、堆等)及一些进程级的资源(如打开文件和信号)。
- 调度和切换：线程上下文切换比进程上下文切换要快得多。  
  
### 浏览器是多进程的
浏览器是多进程的，有一个主控进程，以及每一个tab页面都会新开一个进程（某些情况下多个tab会合并进程）。
如图，查看chrome任务管理器。
![]({{site.url}}/assets/images/2018-9-17-http-url/chromePro.png)

**浏览器进程包括**
- Browser进程：浏览器的主进程（负责协调、主控），只有一个
- 第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建
- GPU进程：最多一个，用于3D绘制
- 浏览器渲染进程（内核）：默认每个Tab页面一个进程，互不影响，控制页面渲染，脚本执行，事件处理等（有时候会优化，如多个空白tab会合并成一个进程）

### 浏览器内核是多线程 
#### 浏览器内核  
简单来说浏览器内核是通过取得页面内容、整理信息（应用CSS）、计算和组合最终输出可视化的图像结果，通常也被称为渲染引擎。
从上面我们可以知道，Chrome浏览器为每个tab页面单独启用进程，因此每个tab网页都有由其独立的渲染引擎实例。  
浏览器内核是多线程，在内核控制下各线程相互配合以保持同步，一个浏览器通常由以下常驻线程组成：
- GUI 渲染线程（图形用户界面）
- JavaScript引擎线程
- 事件触发线程
- 定时触发器线程
- 异步http请求线程  
![](https://dailc.github.io/staticResource/blog/basicKnowledge/whenyouenteraurl/browser_inner_thread.png)

#### GUI 渲染线程
`GUI渲染线程`负责渲染浏览器界面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等。
当界面需要重绘(Repaint)或由于某种操作引发回流(reflow)时,该线程就会执行。  
**GUI渲染线程与JS引擎线程是互斥的** 在Javascript引擎运行脚本期间,GUI渲染线程都是处于挂起状态的,也就是说被”冻结”了.
#### JavaScript引擎线程  
`Javascript引擎`可以称为JS内核，主要负责处理Javascript脚本程序，例如V8引擎。Javascript引擎线程理所当然是负责解析Javascript脚本，运行代码。  
一个Tab页（renderer进程）中无论什么时候都只有一个JS线程在运行JS程序。
#### Javascript是单线程的  
Javascript是单线程的, 那么为什么Javascript要是单线程的？
这是因为Javascript这门脚本语言诞生的使命所致：JavaScript为处理页面中用户的交互，以及操作DOM树、CSS样式树来给用户呈现一份动态而丰富的交互体验和服务器逻辑的交互处理。
如果JavaScript是多线程的方式来操作这些UI DOM，则可能出现UI操作的冲突； 如果Javascript是多线程的话，在多线程的交互下，处于UI中的DOM节点就可能成为一个临界资源，
假设存在两个线程同时操作一个DOM，一个负责修改一个负责删除，那么这个时候就需要浏览器来裁决如何生效哪个线程的执行结果。
当然我们可以通过锁来解决上面的问题。但为了避免因为引入了锁而带来更大的复杂性，Javascript在最初就选择了单线程执行。
#### 事件触发线程
当一个事件被触发时该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理。这些事件可以是当前执行的代码块如定时任务、
也可来自浏览器内核的其他线程如鼠标点击、AJAX异步请求等，但由于JS的单线程关系所有这些事件都得排队等待JS引擎处理。
#### 定时触发器线程  
浏览器定时计数器并不是由JavaScript引擎计数的, 因为JavaScript引擎是单线程的, 
如果处于阻塞线程状态就会影响记计时的准确, 因此通过单独线程来计时并触发定时是更为合理的方案。  
setInterval与setTimeout所在线程，W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms。
#### 异步http请求线程 
在XMLHttpRequest在连接后是通过浏览器新开一个线程请求， 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件放到 JavaScript引擎的处理队列中等待处理。  

#### GUI 渲染线程 与 JavaScript引擎线程互斥
由于JavaScript是可操纵DOM的，如果在修改这些元素属性同时渲染界面（即JavaScript线程和UI线程同时运行），那么渲染线程前后获得的元素数据就可能不一致了。
因此为了防止渲染出现不可预期的结果，浏览器设置GUI渲染线程与JavaScript引擎为互斥的关系，当JavaScript引擎执行时GUI线程会被挂起，GUI更新会被保存在一个队列中等到引擎线程空闲时立即被执行。


## 开启网络线程到发出一个完整的http请求
### DNS查询得到IP  
1. 如果输入的是域名，需要进行DNS解析成IP，查询步骤：
2. 浏览器缓存
3. 本机缓存
4. hosts文件
5. 路由器缓存
6. ISP DNS缓存
7. DNS递归查询（可能存在负载均衡导致每次IP不一样）
### TCP/IP请求
#### TCP三次握手  
![](https://note.youdao.com/yws/public/resource/8601eea9a832e259223ef938bc4a5928/xmlnote/89A21F677AF3469DB7E56D94EFE6F660/74)  
 
总结三次握手过程：
- 第一次握手：起初两端都处于CLOSED关闭状态，Client将标志位SYN置为1，随机产生一个值seq=x，并将该数据包发送给Server，Client进入SYN-SENT状态，等待Server确认；
- 第二次握手：Server收到数据包后由标志位SYN=1得知Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=x+1，随机产生一个值seq=y，并将该数据包发送给Client以确认连接请求，Server进入SYN-RCVD状态，此时操作系统为该TCP连接分配TCP缓存和变量；
- 第三次握手：Client收到确认后，检查ack是否为x+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=y+1，并且此时操作系统为该TCP连接分配TCP缓存和变量，并将该数据包发送给Server，Server检查ack是否为y+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client和Server就可以开始传输数据。

#### TCP四次挥手
![](https://note.youdao.com/yws/public/resource/8601eea9a832e259223ef938bc4a5928/xmlnote/EA7A8241C5B64AA494ABCC7466D43C99/76)  

总结四次挥手过程：  
起初A和B处于ESTABLISHED状态——A发出连接释放报文段并处于FIN-WAIT-1状态——B发出确认报文段且进入CLOSE-WAIT状态——A收到确认后，进入FIN-WAIT-2状态，等待B的连接释放报文段——B没有要向A发出的数据，B发出连接释放报文段且进入LAST-ACK状态——A发出确认报文段且进入TIME-WAIT状态——B收到确认报文段后进入CLOSED状态——A经过等待计时器时间2MSL后，进入CLOSED状态。  

#### GET,POST区别  
GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。  
**GET产生一个TCP数据包,POST产生两个TCP数据包。**  
对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）   
而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）

![](http://mmbiz.qpic.cn/mmbiz/VUGnGjllRE5vZcld02bjOjWPPBRXYdhLcm8TfMjvKvXwbzXTbpUaahYNVFpXh8fIMgqcmbIeEBqFTt7ibiaewMicg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)
### [TCP/IP协议栈]({{site.url}}/http/2018/08/29/tcp-ip/)


## 从服务器接收到请求到对应后台接收到请求
### 负载均衡
用户发起的请求都指向调度服务器（反向代理服务器，譬如安装了nginx控制负载均衡），然后调度服务器根据实际的调度算法，分配不同的请求给对应集群中的服务器执行，然后调度器等待实际服务器的HTTP响应，并将它反馈给用户。
### 后台的处理🐒
- 后端是有统一的验证的，如安全拦截，跨域验证等。如不符合规则，直接返回相应的http报文（如拒绝请求等）
- 当验证通过后，进入实际的后台代码，此时是程序接收到请求，然后执行（譬如查询数据库，大量计算等等）
- 等程序执行完毕后，就会返回一个http响应包（会经过多层封装）,将这个包从后端发送到前端，完成交互  

## 后台和前台的http交互  
### HTTP报文结构
## 缓存问题
## 解析页面流程
## CSS的可视化格式模型
## JS引擎解析过程 

## 参考 
- [http://www.dailichun.com/2018/03/12/whenyouenteraurl.html](http://www.dailichun.com/2018/03/12/whenyouenteraurl.html) 
- [http://www.qnx.com/developers/docs/6.4.1/neutrino/getting_started/s1_procs.html](http://www.qnx.com/developers/docs/6.4.1/neutrino/getting_started/s1_procs.html ) 
- [http://www.imweb.io/topic/58e3bfa845e5c13468f567d5](http://www.imweb.io/topic/58e3bfa845e5c13468f567d5)
- [https://blog.csdn.net/sh435367384/article/details/79652159](https://blog.csdn.net/sh435367384/article/details/79652159)
